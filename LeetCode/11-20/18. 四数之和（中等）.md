### 题目描述

这是 LeetCode 上的 **[18. 四数之和](https://leetcode-cn.com/problems/4sum/solution/shua-chuan-lc-pai-xu-shuang-zhi-zhen-jie-dqx7/)** ，难度为 **中等**。

Tag : 「双指针」、「排序」、「n 数之和」



给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？

找出所有满足条件且不重复的四元组。

注意：答案中不可以包含重复的四元组。

 

示例 1：
```
输入：nums = [1,0,-1,0,-2,2], target = 0

输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]
```
示例 2：
```
输入：nums = [], target = 0

输出：[]
```

提示：
* 0 <= nums.length <= 200
* -$10^9$ <= nums[i] <= $10^9$
* -$10^9$ <= target <= $10^9$

---

### 排序 + 双指针

这道题的思路和「15. 三数之和（中等）」、「16. 最接近的三数之和（中等）」类似。

对数组进行排序，使用四个指针 `i`、`j` 、`k` 和 `p` 分别代表要找的四个数。

1. 通过枚举 `i` 确定第一个数，枚举 `j` 确定第二个数，另外两个指针 `k` 和 `p` 分别从左边 `j + 1` 和右边 `n - 1` 往中间移动，找到满足 `nums[i] + nums[j] + nums[k] + nums[p] == t` 的所有组合。

2. `k` 和 `p` 指针的移动逻辑，分情况讨论 `sum = nums[i] + nums[j] + nums[k] + nums[p]` ：
    * `sum` > `target`：`p` 左移，使 `sum` 变小
    * `sum` < `target`：`k` 右移，使 `sum` 变大
    * `sum` = `target`：将组合加入结果集，`k` 右移继续进行检查

题目要求不能包含重复元素，所以我们要对 `i`、`j` 和 `k` 进行去重，去重逻辑是对于相同的数，只使用第一个。

代码：
```Java []
class Solution {
    public List<List<Integer>> fourSum(int[] nums, int t) {
        Arrays.sort(nums);
        int n = nums.length;
        List<List<Integer>> ans = new ArrayList<>();
        for (int i = 0; i < n; i++) { // 确定第一个数
            if (i > 0 && nums[i] == nums[i - 1]) continue; // 对第一个数进行去重（相同的数只取第一个）
            for (int j = i + 1; j < n; j++) { // 确定第二个数
                if (j > i + 1 && nums[j] == nums[j - 1]) continue; // 对第二个数进行去重（相同的数只取第一个）
                // 确定第三个数和第四个数
                int k = j + 1, p = n - 1;
                while (k < p) {
                
                    // 对第三个数进行去重（相同的数只取第一个）
                    while (k > j + 1 && k < n && nums[k] == nums[k - 1]) k++; 
                    // 如果 k 跳过相同元素之后的位置超过了 p，本次循环结束
                    if (k >= p) break;
                    
                    int sum = nums[i] + nums[j] + nums[k] + nums[p];
                    if (sum == t) {
                        ans.add(Arrays.asList(nums[i], nums[j], nums[k], nums[p]));
                        k++;
                    } else if (sum > t) {
                        p--;
                    } else if (sum < t) {
                        k++;
                    }
                }
            }
        }
        return ans;
    }
}
```
* 时间复杂度：`i` 和 `j` 是直接枚举确定，复杂度为 $O(n^2)$，当确定下来 `i` 和 `j` 之后，通过双指针确定 `k` 和 `p` ，也就是对于每一组 `i` 和 `j` 而言复杂度为 $O(n)$。总的复杂度为 $O(n^3)$
* 空间复杂度：$O(n)$

---
### 最后

这是我们「刷穿 LeetCode」系列文章的第 `No.18` 篇，系列开始于 2021/01/01，截止于起始日 LeetCode 上共有 1916 道题目，部分是有锁题，我们将先将所有不带锁的题目刷完。

在这个系列文章里面，除了讲解解题思路以外，还会尽可能给出最为简洁的代码。如果涉及通解还会相应的代码模板。

为了方便各位同学能够电脑上进行调试和提交代码，我建立了相关的仓库：https://github.com/SharingSource/LogicStack-LeetCode。

在仓库地址里，你可以看到系列文章的题解链接、系列文章的相应代码、LeetCode 原题链接和其他优选题解。

