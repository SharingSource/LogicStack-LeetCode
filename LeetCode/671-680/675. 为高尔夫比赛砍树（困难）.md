### é¢˜ç›®æè¿°

è¿™æ˜¯ LeetCode ä¸Šçš„ **[675. ä¸ºé«˜å°”å¤«æ¯”èµ›ç æ ‘](https://leetcode.cn/problems/cut-off-trees-for-golf-event/solution/by-ac_oier-ksth/)** ï¼Œéš¾åº¦ä¸º **å›°éš¾**ã€‚

Tag : ã€Œå›¾è®º BFSã€ã€ã€ŒAStar ç®—æ³•ã€ã€ã€Œå¯å‘å¼æœç´¢ã€ã€ã€Œå¹¶æŸ¥é›†ã€



ä½ è¢«è¯·æ¥ç»™ä¸€ä¸ªè¦ä¸¾åŠé«˜å°”å¤«æ¯”èµ›çš„æ ‘æ—ç æ ‘ã€‚æ ‘æ—ç”±ä¸€ä¸ªÂ $m \times n$ çš„çŸ©é˜µè¡¨ç¤ºï¼Œ åœ¨è¿™ä¸ªçŸ©é˜µä¸­ï¼š

* $0$ è¡¨ç¤ºéšœç¢ï¼Œæ— æ³•è§¦ç¢°
* $1$Â è¡¨ç¤ºåœ°é¢ï¼Œå¯ä»¥è¡Œèµ°
* æ¯” $1$ å¤§çš„æ•°Â è¡¨ç¤ºæœ‰æ ‘çš„å•å…ƒæ ¼ï¼Œå¯ä»¥è¡Œèµ°ï¼Œæ•°å€¼è¡¨ç¤ºæ ‘çš„é«˜åº¦

æ¯ä¸€æ­¥ï¼Œä½ éƒ½å¯ä»¥å‘ä¸Šã€ä¸‹ã€å·¦ã€å³å››ä¸ªæ–¹å‘ä¹‹ä¸€ç§»åŠ¨ä¸€ä¸ªå•ä½ï¼Œå¦‚æœä½ ç«™çš„åœ°æ–¹æœ‰ä¸€æ£µæ ‘ï¼Œé‚£ä¹ˆä½ å¯ä»¥å†³å®šæ˜¯å¦è¦ç å€’å®ƒã€‚

ä½ éœ€è¦æŒ‰ç…§æ ‘çš„é«˜åº¦ä»ä½å‘é«˜ç æ‰æ‰€æœ‰çš„æ ‘ï¼Œæ¯ç è¿‡ä¸€é¢—æ ‘ï¼Œè¯¥å•å…ƒæ ¼çš„å€¼å˜ä¸º $1$ï¼ˆå³å˜ä¸ºåœ°é¢ï¼‰ã€‚

ä½ å°†ä» $(0, 0)$ ç‚¹å¼€å§‹å·¥ä½œï¼Œè¿”å›ä½ ç å®Œæ‰€æœ‰æ ‘éœ€è¦èµ°çš„æœ€å°æ­¥æ•°ã€‚ å¦‚æœä½ æ— æ³•ç å®Œæ‰€æœ‰çš„æ ‘ï¼Œè¿”å› $-1$ ã€‚

å¯ä»¥ä¿è¯çš„æ˜¯ï¼Œæ²¡æœ‰ä¸¤æ£µæ ‘çš„é«˜åº¦æ˜¯ç›¸åŒçš„ï¼Œå¹¶ä¸”ä½ è‡³å°‘éœ€è¦ç å€’ä¸€æ£µæ ‘ã€‚

ç¤ºä¾‹ 1ï¼š
![](https://assets.leetcode.com/uploads/2020/11/26/trees1.jpg)
```
è¾“å…¥ï¼šforest = [[1,2,3],[0,0,4],[7,6,5]]

è¾“å‡ºï¼š6

è§£é‡Šï¼šæ²¿ç€ä¸Šé¢çš„è·¯å¾„ï¼Œä½ å¯ä»¥ç”¨ 6 æ­¥ï¼ŒæŒ‰ä»æœ€çŸ®åˆ°æœ€é«˜çš„é¡ºåºç æ‰è¿™äº›æ ‘ã€‚
```
ç¤ºä¾‹ 2ï¼š
![](https://assets.leetcode.com/uploads/2020/11/26/trees2.jpg)
```
è¾“å…¥ï¼šforest = [[1,2,3],[0,0,0],[7,6,5]]

è¾“å‡ºï¼š-1

è§£é‡Šï¼šç”±äºä¸­é—´ä¸€è¡Œè¢«éšœç¢é˜»å¡ï¼Œæ— æ³•è®¿é—®æœ€ä¸‹é¢ä¸€è¡Œä¸­çš„æ ‘ã€‚
```
ç¤ºä¾‹ 3ï¼š
```
è¾“å…¥ï¼šforest = [[2,3,4],[0,0,5],[8,7,6]]

è¾“å‡ºï¼š6

è§£é‡Šï¼šå¯ä»¥æŒ‰ä¸ç¤ºä¾‹ 1 ç›¸åŒçš„è·¯å¾„æ¥ç æ‰æ‰€æœ‰çš„æ ‘ã€‚
(0,0) ä½ç½®çš„æ ‘ï¼Œå¯ä»¥ç›´æ¥ç å»ï¼Œä¸ç”¨ç®—æ­¥æ•°ã€‚
```

æç¤ºï¼š
* $m == forest.length$
* $n == forest[i].length$
* $1 <= m, n <= 50$
* $0 <= forest[i][j] <= 10^9$

---

### åŸºæœ¬åˆ†æ 

åŸºæœ¬é¢˜æ„ä¸ºï¼šç»™å®šä¸€ä¸ª $n \times m$ çš„çŸ©é˜µï¼Œæ¯æ¬¡èƒ½å¤Ÿåœ¨å½“å‰ä½ç½®å¾€ã€Œå››è”é€šã€ç§»åŠ¨ä¸€ä¸ªå•ä½ï¼Œå…¶ä¸­ $0$ çš„ä½ç½®ä»£è¡¨éšœç¢ï¼ˆæ— æ³•è®¿é—®ï¼‰ï¼Œ$1$ çš„ä½ç½®ä»£è¡¨å¹³åœ°ï¼ˆå¯ç›´æ¥è®¿é—®ï¼Œä¸”æ— é¡»è¿›è¡Œä»»ä½•å†³ç­–ï¼‰ï¼Œå…¶ä½™å¤§äº $1$ çš„ä½ç½®ä»£è¡¨æœ‰æ ‘ï¼Œç»è¿‡è¯¥ä½ç½®çš„æ—¶å€™å¯ä»¥è€ƒè™‘å°†æ ‘ç æ‰ï¼ˆç›¸åº”å€¼å˜ä¸ºå¹³åœ° $1$ï¼‰ã€‚

åŒæ—¶é¢˜ç›®é™å®šäº†æˆ‘ä»¬åªèƒ½æŒ‰ç…§ã€Œä»ä½åˆ°é«˜ã€çš„é¡ºåºè¿›è¡Œç æ ‘ï¼Œå¹¶ä¸”å›¾ä¸­ä¸å­˜åœ¨é«˜åº¦ç›¸ç­‰çš„ä¸¤æ£µæ ‘ï¼Œè¿™æ„å‘³ç€ **æ•´ä¸ªç æ ‘çš„é¡ºåºå”¯ä¸€ç¡®å®šï¼Œå°±æ˜¯å¯¹æ‰€æœ‰æœ‰æ ‘çš„åœ°æ–¹è¿›è¡Œã€Œé«˜åº¦ã€æ’å‡åºï¼Œå³æ˜¯å®Œæ•´çš„ç æ ‘è·¯çº¿ã€‚**

è€Œå¦å¤–ä¸€ä¸ªæ›´ä¸ºé‡è¦çš„æ€§è´¨æ˜¯ï¼š**ç‚¹ä¸ç‚¹ä¹‹é—´çš„æœ€çŸ­è·¯å¾„ï¼Œä¸ä¼šéšç€ç æ ‘è¿‡ç¨‹çš„è¿›è¡Œè€Œå‘ç”Ÿå˜åŒ–ï¼ˆæŸä¸ªæ ‘ç‚¹è¢«ç æ‰ï¼Œåªä¼šå˜ä¸ºå¹³åœ°ï¼Œä¸ä¼šå˜ä¸ºé˜»ç¢ç‚¹ï¼Œä»å¯é€šè¿‡ï¼‰ã€‚**

ç»¼ä¸Šï¼Œ**ç æ ‘çš„è·¯çº¿å”¯ä¸€ç¡®å®šï¼Œå½“æˆ‘ä»¬æ±‚å‡ºæ¯ä¸¤ä¸ªç›¸é‚»çš„ç æ ‘ç‚¹æœ€çŸ­è·¯å¾„ï¼Œå¹¶è¿›è¡Œç´¯åŠ å³æ˜¯ç­”æ¡ˆï¼ˆæ•´æ¡ç æ ‘è·¯å¾„çš„æœ€å°‘æ­¥æ•°ï¼‰**ã€‚

---

### BFS

å› æ­¤ï¼Œå†ç»“åˆæ•°æ®èŒƒå›´åªæœ‰ $50$ï¼Œå¹¶ä¸”ç‚¹ä¸ç‚¹ä¹‹é—´è¾¹æƒä¸º $1$ï¼ˆæ¯æ¬¡ç§»åŠ¨ç®—ä¸€æ­¥ï¼‰ï¼Œæˆ‘ä»¬å¯ä»¥ç›´æ¥è¿›è¡Œ `BFS` è¿›è¡Œæ±‚è§£ã€‚

å…ˆå¯¹æ•´å¼ å›¾è¿›è¡Œä¸€æ¬¡éå†ï¼Œé¢„å¤„ç†å‡ºæ‰€æœ‰çš„æ ‘ç‚¹ï¼ˆä»¥ä¸‰å…ƒç»„ $(height, x, y)$ çš„å½¢å¼è¿›è¡Œå­˜å‚¨ï¼‰ï¼Œå¹¶å¯¹å…¶ä»¥ $height$ æ’å‡åºï¼Œå¾—åˆ°å”¯ä¸€ç¡®å®šçš„ç æ ‘è·¯å¾„ã€‚

ä¹‹åå°±æ˜¯è®¡ç®—ç æ ‘è·¯å¾„ä¸­ç›¸é‚»ç‚¹çš„æœ€çŸ­è·ç¦»ï¼Œè¿ç”¨ `BFS` æ±‚è§£ä»»æ„ä¸¤ç‚¹çš„æœ€çŸ­è·¯å¾„å¤æ‚åº¦ä¸º $O(n \times m)$ï¼Œæˆ‘ä»¬æœ€å¤šæœ‰ $n \times m$ ä¸ªæ ‘ç‚¹ï¼Œå› æ­¤æ•´ä½“å¤æ‚åº¦ä¸º $O(n^2 * \times m^2)$ã€‚

æ±‚è§£ç›¸é‚»ç‚¹çš„æœ€çŸ­è·ç¦»çš„éƒ¨åˆ†ä¹Ÿæ˜¯æ•´ä¸ªç®—æ³•çš„å¤æ‚åº¦ä¸Šç•Œï¼Œæ•°æ®èŒƒå›´åªæœ‰ $50$ï¼Œè®¡ç®—é‡ä¸è¶…è¿‡ $10^7$ï¼Œå¯ä»¥è¿‡ã€‚

ä»£ç ï¼š
```Java
class Solution {
    int N = 50;
    int[][] g = new int[N][N];
    int n, m;
    List<int[]> list = new ArrayList<>();
    public int cutOffTree(List<List<Integer>> forest) {
        n = forest.size(); m = forest.get(0).size();
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                g[i][j] = forest.get(i).get(j);
                if (g[i][j] > 1) list.add(new int[]{g[i][j], i, j});
            }
        }
        Collections.sort(list, (a,b)->a[0]-b[0]);
        if (g[0][0] == 0) return -1;
        int x = 0, y = 0, ans = 0;
        for (int[] ne : list) {
            int nx = ne[1], ny = ne[2];
            int d = bfs(x, y, nx, ny);
            if (d == -1) return -1;
            ans += d;
            x = nx; y = ny;
        }
        return ans;
    }
    int[][] dirs = new int[][]{{0,1},{0,-1},{1,0},{-1,0}};
    int bfs(int X, int Y, int P, int Q) {
        if (X == P && Y == Q) return 0;
        boolean[][] vis = new boolean[n][m];
        Deque<int[]> d = new ArrayDeque<>();
        d.addLast(new int[]{X, Y});
        vis[X][Y] = true;
        int ans = 0;
        while (!d.isEmpty()) {
            int size = d.size();
            while (size-- > 0) {
                int[] info = d.pollFirst();
                int x = info[0], y = info[1];
                for (int[] di : dirs) {
                    int nx = x + di[0], ny = y + di[1];
                    if (nx < 0 || nx >= n || ny < 0 || ny >= m) continue;
                    if (g[nx][ny] == 0 || vis[nx][ny]) continue;
                    if (nx == P && ny == Q) return ans + 1;
                    d.addLast(new int[]{nx, ny});
                    vis[nx][ny] = true;
                }
            }
            ans++;
        }
        return -1;
    }
}
```
* æ—¶é—´å¤æ‚åº¦ï¼šé¢„å¤„ç†å‡ºæ‰€æœ‰æ ‘ç‚¹çš„å¤æ‚åº¦ä¸º $O(n \times m)$ï¼Œå¯¹æ ‘ç‚¹è¿›è¡Œæ’åºçš„å¤æ‚åº¦ä¸º $O(nm \log{nm})$ï¼Œæœ€å¤šæœ‰ $n \times m$ ä¸ªæ ‘ç‚¹ï¼Œå¯¹æ¯ä¸¤ä¸ªç›¸é‚»æ ‘ç‚¹è¿ç”¨ `BFS`  æ±‚æœ€çŸ­è·¯çš„å¤æ‚åº¦ä¸º $O(n \times m)$ï¼Œç»Ÿè®¡å®Œæ•´è·¯å¾„çš„å¤æ‚åº¦ä¸º $O(n^2 \times m^2)$
* ç©ºé—´å¤æ‚åº¦ï¼š$O(n \times m)$

---

### AStar ç®—æ³•

**ç”±äºé—®é¢˜çš„æœ¬è´¨æ˜¯æ±‚æœ€çŸ­è·¯ï¼ŒåŒæ—¶åŸé—®é¢˜çš„è¾¹æƒä¸º $1$ï¼Œå› æ­¤å¥—ç”¨å…¶ä»–å¤æ‚åº¦æ¯” `BFS` é«˜çš„æœ€çŸ­è·¯ç®—æ³•ï¼Œå¯¹äºæœ¬é¢˜è€Œè¨€æ˜¯æ²¡æœ‰æ„ä¹‰ï¼Œä½†è¿ç”¨å¯å‘å¼æœç´¢ AStar ç®—æ³•æ¥ä¼˜åŒ–åˆ™æ˜¯æœ‰æ„ä¹‰ã€‚**

å› ä¸ºåœ¨ `BFS` è¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬ä¼šæ— å·®åˆ«å¾€ã€Œå››è”é€šã€æ–¹å‘è¿›è¡Œæœç´¢ï¼Œç›´åˆ°æ‰¾åˆ°ã€Œå½“å‰æ ‘ç‚¹çš„ä¸‹ä¸€ä¸ªç›®æ ‡ä½ç½®ã€ä¸ºæ­¢ï¼Œè€Œå®é™…ä¸Šï¼Œä¸¤ç‚¹ä¹‹é—´çš„æœ€çŸ­è·¯å¾„å¾€å¾€ä¸ä¸¤ç‚¹ä¹‹é—´çš„ç›¸å¯¹ä½ç½®ç›¸å…³ã€‚

ä¸¾ä¸ª ğŸŒ°ï¼Œå½“å‰æˆ‘ä»¬åœ¨ä½ç½® $S$ï¼Œæˆ‘ä»¬ç›®æ ‡ä½ç½®æ˜¯ $T$ï¼Œè€Œ $T$ åœ¨ $S$ çš„å³ä¸‹æ–¹ï¼Œæ­¤æ—¶æˆ‘ä»¬åº”å½“ä¼˜å…ˆæœç´¢æ–¹å‘"å¾€å³ä¸‹æ–¹"çš„è·¯å¾„ï¼Œå½“æ— æ³•ä»"å¾€å³ä¸‹æ–¹"çš„è·¯å¾„åˆ°è¾¾ $T$ï¼Œæˆ‘ä»¬å†è€ƒè™‘æœç´¢å…¶ä»–å¤§æ–¹å‘çš„è·¯å¾„ï¼š

![image.png](https://pic.leetcode-cn.com/1653270722-gYnbgm-image.png)

å¦‚ä½•è®¾è®¡è¿™æ ·å¸¦æœ‰ä¼˜å…ˆçº§çš„æœç´¢é¡ºåºï¼Œåˆ™æ˜¯ AStar ç®—æ³•ã€Œå¯å‘å¼å‡½æ•°ã€çš„è®¾è®¡è¿‡ç¨‹ï¼Œå…¶æœ¬è´¨æ˜¯å¯¹åº”äº†å¯¹ã€Œæœ€å°æ­¥æ•°ã€çš„ä¼°ç®—ï¼Œåªæœ‰å½“æˆ‘ä»¬ç¡®ä¿ã€Œæœ€å°æ­¥æ•°ä¼°ç®— $\leq $ å®é™…æœ€å°æ­¥æ•°ã€ï¼ŒAStar ç®—æ³•çš„æ­£ç¡®æ€§æ‰å¾—ä»¥ä¿è¯ã€‚

å› æ­¤æˆ‘ä»¬å¾€å¾€ä¼šç›´æ¥ä½¿ç”¨ã€Œç†è®ºæœ€å°æ­¥æ•°ã€æ¥ä½œä¸ºå¯å‘å¼å‡½æ•°çš„ï¼Œå¯¹äºæœ¬é¢˜ï¼Œå¯ç›´æ¥ä½¿ç”¨ã€Œæ›¼å“ˆé¡¿è·ç¦»ã€ä½œä¸ºã€Œç†è®ºæœ€å°æ­¥æ•°ã€ã€‚

å› æ­¤ï¼Œå¦‚æœæˆ‘ä»¬æ˜¯è¦ä»æºç‚¹ $S$ åˆ°æ±‡ç‚¹ $T$ï¼Œå¹¶ä¸”å½“å‰ä½äºä¸­é€”ç‚¹ $x$ çš„è¯ï¼Œç‚¹ $x$ çš„æœ€å°æ­¥æ•°ä¼°ç®—åŒ…æ‹¬ä¸¤éƒ¨åˆ†ï¼š**åˆ°ç‚¹ $x$ çš„å®é™…æ­¥æ•° + ä»ç‚¹ $x$ åˆ°ç‚¹ $T$ çš„ç†è®ºæœ€å°æ­¥æ•°ï¼ˆæ›¼å“ˆé¡¿è·ç¦»ï¼‰**ã€‚ä½¿ç”¨ã€Œä¼˜å…ˆé˜Ÿåˆ—ã€æŒ‰ç…§ã€Œæ€»çš„æœ€å°æ­¥æ•°ä¼°ç®—ã€è¿›è¡Œå‡ºé˜Ÿï¼Œå³å¯å®ç° AStar ç®—æ³•çš„æœç´¢é¡ºåºã€‚

> **AStar ç®—æ³•åšè¿‡å¾ˆå¤šæ¬¡äº†ï¼Œç›¸å…³åˆé›†å¯ä»¥åœ¨ [è¿™é‡Œ](https://sharingsource.github.io/tags/AStar-%E7%AE%97%E6%B3%95/) çœ‹åˆ°ã€‚**
å¦å¤–ï¼Œç½‘ä¸Šå¾ˆå¤šå¯¹ AStar æ­£ç¡®æ€§è¯æ˜ä¸äº†è§£çš„äººï¼Œä¼šç¼ºå°‘ä»¥ä¸‹ `map.get(nidx) > step + 1` åˆ¤æ–­é€»è¾‘ã€‚
ç®€å•æ¥è¯´ï¼Œå¯å‘å¼å‡½æ•°çš„è®¾è®¡æ˜¯é’ˆå¯¹æ±‡ç‚¹è€Œè¨€çš„ï¼Œ**å› æ­¤ AStar ç®—æ³•æœç´¢è¿‡ç¨‹åªç¡®ä¿å¯¹ $T$ çš„å‡ºå…¥é˜Ÿæ¬¡åºèƒ½å¤Ÿå¯¹åº”å›åˆ°ç‚¹ $T$ ç¬¬ $k$ çŸ­è·¯ï¼Œè€Œå¯¹äºå…¶ä½™ç‚¹çš„å‡ºå…¥é˜Ÿæ¬¡åºåˆ°å…¶ä½™ç‚¹çš„æœ€çŸ­è·¯æ²¡æœ‰å¿…ç„¶çš„å¯¹åº”å…³ç³»ï¼Œå› æ­¤å½“æŸä¸ªç‚¹çš„æœ€å°æ­¥æ•°è¢«æ›´æ–°ï¼Œæˆ‘ä»¬æ˜¯è¦å°†å…¶è¿›è¡Œå†æ¬¡å…¥é˜Ÿçš„ã€‚**

ä»£ç ï¼š
```Java
class Solution {
    int N = 50;
    int[][] g = new int[N][N];
    int n, m;
    List<int[]> list = new ArrayList<>();
    public int cutOffTree(List<List<Integer>> forest) {
        n = forest.size(); m = forest.get(0).size();
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                g[i][j] = forest.get(i).get(j);
                if (g[i][j] > 1) list.add(new int[]{g[i][j], i, j});
            }
        }
        if (g[0][0] == 0) return -1;
        Collections.sort(list, (a,b)->a[0]-b[0]);
        int x = 0, y = 0, ans = 0;
        for (int[] ne : list) {
            int nx = ne[1], ny = ne[2];
            int d = astar(x, y, nx, ny);
            if (d == -1) return -1;
            ans += d;
            x = nx; y = ny;
        }
        return ans;
    }
    int[][] dirs = new int[][]{{0,1},{0,-1},{1,0},{-1,0}};
    int getIdx(int x, int y) {
        return x * m + y;
    }
    int f(int X, int Y, int P, int Q) {
        return Math.abs(X - P) + Math.abs(Y - Q);
    }
    int astar(int X, int Y, int P, int Q) {
        if (X == P && Y == Q) return 0;
        Map<Integer, Integer> map = new HashMap<>();
        PriorityQueue<int[]> q = new PriorityQueue<>((a,b)->a[0]-b[0]);
        q.add(new int[]{f(X, Y, P, Q), X, Y});
        map.put(getIdx(X, Y), 0);
        while (!q.isEmpty()) {
            int[] info = q.poll();
            int x = info[1], y = info[2], step = map.get(getIdx(x, y));
            for (int[] di : dirs) {
                int nx = x + di[0], ny = y + di[1], nidx = getIdx(nx, ny);
                if (nx < 0 || nx >= n || ny < 0 || ny >= m) continue;
                if (g[nx][ny] == 0) continue;
                if (nx == P && ny == Q) return step + 1;
                if (!map.containsKey(nidx) || map.get(nidx) > step + 1) {
                    q.add(new int[]{step + 1 + f(nx, ny, P, Q), nx, ny});
                    map.put(nidx, step + 1);
                }
            }
        }
        return -1;
    }
}
```
* æ—¶é—´å¤æ‚åº¦ï¼šå¯å‘å¼æœç´¢åˆ†ææ—¶ç©ºå¤æ‚åº¦æ„ä¹‰ä¸å¤§
* ç©ºé—´å¤æ‚åº¦ï¼šå¯å‘å¼æœç´¢åˆ†ææ—¶ç©ºå¤æ‚åº¦æ„ä¹‰ä¸å¤§

---

### AStar ç®—æ³• + å¹¶æŸ¥é›†é¢„å¤„ç†æ— è§£

æˆ‘ä»¬çŸ¥é“ï¼ŒAStar ç®—æ³•ä½¿ç”¨åˆ°äº†ã€Œä¼˜å…ˆé˜Ÿåˆ—ï¼ˆå †ï¼‰ã€æ¥è¿›è¡Œå¯å‘å¼æœç´¢ï¼Œè€Œå¯¹äºä¸€äº›æœ€ä½³è·¯å¾„æ–¹å‘ä¸ä¸¤ç‚¹ç›¸å¯¹ä½ç½®ç›¸åï¼ˆä¾‹å¦‚ $T$ åœ¨ $S$ çš„å³è¾¹ï¼Œä½†ç”±äºå­˜åœ¨éšœç¢ï¼Œæœ€çŸ­è·¯å¾„éœ€è¦å…ˆä»å·¦è¾¹ç»•ä¸€åœˆæ‰èƒ½åˆ° $T$ï¼‰ï¼ŒAStar åè€Œä¼šå› ä¸ºä¼˜å…ˆé˜Ÿåˆ—ï¼ˆå †ï¼‰è€Œå¤šä¸€ä¸ª $\log$ çš„å¤æ‚åº¦ã€‚

å› æ­¤ä¸€ä¸ªå¯è¡Œçš„ä¼˜åŒ–æ˜¯ï¼Œæˆ‘ä»¬å…ˆæå‰å¤„ç†ã€Œæ— è§£ã€çš„æƒ…å†µï¼Œå¸¸è§çš„åšæ³•æ˜¯åœ¨é¢„å¤„ç†è¿‡ç¨‹ä¸­è¿ç”¨ã€Œå¹¶æŸ¥é›†ã€æ¥ç»´æŠ¤è¿é€šæ€§ã€‚

è¿™ç§å¯¹äºä¸å½±å“å¤æ‚åº¦ä¸Šç•Œçš„é¢„å¤„ç†ç›¸æ¯”åç»­å¯èƒ½å‡ºç°çš„å¤§é‡æ— æ•ˆæœç´¢ï¼ˆæœ€ç»ˆæ— è§£ï¼‰çš„è®¡ç®—é‡è€Œè¨€ï¼Œæ˜¯æœ‰ç›Šçš„ã€‚

ä»£ç ï¼š
```Java
class Solution {
    int N = 50;
    int[][] g = new int[N][N];
    int n, m;
    int[] p = new int[N * N + 10];
    List<int[]> list = new ArrayList<>();
    void union(int a, int b) {
        p[find(a)] = p[find(b)];
    }
    boolean query(int a, int b) {
        return find(a) == find(b);
    }
    int find(int x) {
        if (p[x] != x) p[x] = find(p[x]);
        return p[x];
    }
    int getIdx(int x, int y) {
        return x * m + y;
    }
    public int cutOffTree(List<List<Integer>> forest) {
        n = forest.size(); m = forest.get(0).size();
        // é¢„å¤„ç†è¿‡ç¨‹ä¸­ï¼ŒåŒæ—¶ä½¿ç”¨ã€Œå¹¶æŸ¥é›†ã€ç»´æŠ¤è¿é€šæ€§
        for (int i = 0; i < n * m; i++) p[i] = i;
        int[][] tempDirs = new int[][]{{0,-1},{-1,0}};
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                g[i][j] = forest.get(i).get(j);
                if (g[i][j] > 1) list.add(new int[]{g[i][j], i, j});
                if (g[i][j] == 0) continue;
                // åªä¸å·¦æ–¹å’Œä¸Šæ–¹çš„åŒºåŸŸè”é€šå³å¯ç¡®ä¿ä¸é‡ä¸æ¼
                for (int[] di : tempDirs) {
                    int nx = i + di[0], ny = j + di[1];
                    if (nx < 0 || nx >= n || ny < 0 || ny >= m) continue;
                    if (g[nx][ny] != 0) union(getIdx(i, j), getIdx(nx, ny));
                }
            }
        }
        // è‹¥ä¸æ»¡è¶³æ‰€æœ‰æ ‘ç‚¹å‡ä¸ (0,0)ï¼Œæå‰è¿”å›æ— è§£
        for (int[] info : list) {
            int x = info[1], y = info[2];
            if (!query(getIdx(0, 0), getIdx(x, y))) return -1;
        }
        Collections.sort(list, (a,b)->a[0]-b[0]);
        int x = 0, y = 0, ans = 0;
        for (int[] ne : list) {
            int nx = ne[1], ny = ne[2];
            int d = astar(x, y, nx, ny);
            if (d == -1) return -1;
            ans += d;
            x = nx; y = ny;
        }
        return ans;
    }
    int f(int X, int Y, int P, int Q) {
        return Math.abs(X - P) + Math.abs(Y - Q);
    }
    int[][] dirs = new int[][]{{0,1},{0,-1},{1,0},{-1,0}};
    int astar(int X, int Y, int P, int Q) {
        if (X == P && Y == Q) return 0;
        Map<Integer, Integer> map = new HashMap<>();
        PriorityQueue<int[]> q = new PriorityQueue<>((a,b)->a[0]-b[0]);
        q.add(new int[]{f(X, Y, P, Q), X, Y});
        map.put(getIdx(X, Y), 0);
        while (!q.isEmpty()) {
            int[] info = q.poll();
            int x = info[1], y = info[2], step = map.get(getIdx(x, y));
            for (int[] di : dirs) {
                int nx = x + di[0], ny = y + di[1], nidx = getIdx(nx, ny);
                if (nx < 0 || nx >= n || ny < 0 || ny >= m) continue;
                if (g[nx][ny] == 0) continue;
                if (nx == P && ny == Q) return step + 1;
                if (!map.containsKey(nidx) || map.get(nidx) > step + 1) {
                    q.add(new int[]{step + 1 + f(nx, ny, P, Q), nx, ny});
                    map.put(nidx, step + 1);
                }
            }
        }
        return -1;
    }
}
```
* æ—¶é—´å¤æ‚åº¦ï¼šå¯å‘å¼æœç´¢åˆ†ææ—¶ç©ºå¤æ‚åº¦æ„ä¹‰ä¸å¤§
* ç©ºé—´å¤æ‚åº¦ï¼šå¯å‘å¼æœç´¢åˆ†ææ—¶ç©ºå¤æ‚åº¦æ„ä¹‰ä¸å¤§

---

### æœ€å

è¿™æ˜¯æˆ‘ä»¬ã€Œåˆ·ç©¿ LeetCodeã€ç³»åˆ—æ–‡ç« çš„ç¬¬ `No.675` ç¯‡ï¼Œç³»åˆ—å¼€å§‹äº 2021/01/01ï¼Œæˆªæ­¢äºèµ·å§‹æ—¥ LeetCode ä¸Šå…±æœ‰ 1916 é“é¢˜ç›®ï¼Œéƒ¨åˆ†æ˜¯æœ‰é”é¢˜ï¼Œæˆ‘ä»¬å°†å…ˆæŠŠæ‰€æœ‰ä¸å¸¦é”çš„é¢˜ç›®åˆ·å®Œã€‚

åœ¨è¿™ä¸ªç³»åˆ—æ–‡ç« é‡Œé¢ï¼Œé™¤äº†è®²è§£è§£é¢˜æ€è·¯ä»¥å¤–ï¼Œè¿˜ä¼šå°½å¯èƒ½ç»™å‡ºæœ€ä¸ºç®€æ´çš„ä»£ç ã€‚å¦‚æœæ¶‰åŠé€šè§£è¿˜ä¼šç›¸åº”çš„ä»£ç æ¨¡æ¿ã€‚

ä¸ºäº†æ–¹ä¾¿å„ä½åŒå­¦èƒ½å¤Ÿç”µè„‘ä¸Šè¿›è¡Œè°ƒè¯•å’Œæäº¤ä»£ç ï¼Œæˆ‘å»ºç«‹äº†ç›¸å…³çš„ä»“åº“ï¼šhttps://github.com/SharingSource/LogicStack-LeetCode ã€‚

åœ¨ä»“åº“åœ°å€é‡Œï¼Œä½ å¯ä»¥çœ‹åˆ°ç³»åˆ—æ–‡ç« çš„é¢˜è§£é“¾æ¥ã€ç³»åˆ—æ–‡ç« çš„ç›¸åº”ä»£ç ã€LeetCode åŸé¢˜é“¾æ¥å’Œå…¶ä»–ä¼˜é€‰é¢˜è§£ã€‚

