### é¢˜ç›®æè¿°

è¿™æ˜¯ LeetCode ä¸Šçš„ **[124. äºŒå‰æ ‘ä¸­çš„æœ€å¤§è·¯å¾„å’Œ](https://leetcode.cn/problems/binary-tree-maximum-path-sum/solutions/2451624/gong-shui-san-xie-jian-dan-di-gui-shu-xi-nlci/)** ï¼Œéš¾åº¦ä¸º **å›°éš¾**ã€‚

Tag : ã€Œé€’å½’ã€ã€ã€ŒäºŒå‰æ ‘ã€ã€ã€ŒDFSã€ã€ã€Œæ ‘å½¢ DPã€ã€ã€ŒåŠ¨æ€è§„åˆ’ã€



äºŒå‰æ ‘ä¸­çš„ è·¯å¾„ è¢«å®šä¹‰ä¸ºä¸€æ¡èŠ‚ç‚¹åºåˆ—ï¼Œåºåˆ—ä¸­æ¯å¯¹ç›¸é‚»èŠ‚ç‚¹ä¹‹é—´éƒ½å­˜åœ¨ä¸€æ¡è¾¹ã€‚åŒä¸€ä¸ªèŠ‚ç‚¹åœ¨ä¸€æ¡è·¯å¾„åºåˆ—ä¸­ è‡³å¤šå‡ºç°ä¸€æ¬¡ ã€‚è¯¥è·¯å¾„ è‡³å°‘åŒ…å«ä¸€ä¸ª èŠ‚ç‚¹ï¼Œä¸”ä¸ä¸€å®šç»è¿‡æ ¹èŠ‚ç‚¹ã€‚

è·¯å¾„å’Œ æ˜¯è·¯å¾„ä¸­å„èŠ‚ç‚¹å€¼çš„æ€»å’Œã€‚

ç»™ä½ ä¸€ä¸ªäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ `root`ï¼Œè¿”å›å…¶ æœ€å¤§è·¯å¾„å’Œ ã€‚

ç¤ºä¾‹ 1ï¼š
![](https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg)

```
è¾“å…¥ï¼šroot = [1,2,3]

è¾“å‡ºï¼š6

è§£é‡Šï¼šæœ€ä¼˜è·¯å¾„æ˜¯ 2 -> 1 -> 3 ï¼Œè·¯å¾„å’Œä¸º 2 + 1 + 3 = 6
```
ç¤ºä¾‹ 2ï¼š
![](https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg)
```
è¾“å…¥ï¼šroot = [-10,9,20,null,null,15,7]

è¾“å‡ºï¼š42

è§£é‡Šï¼šæœ€ä¼˜è·¯å¾„æ˜¯ 15 -> 20 -> 7 ï¼Œè·¯å¾„å’Œä¸º 15 + 20 + 7 = 42
```

æç¤ºï¼š
* æ ‘ä¸­èŠ‚ç‚¹æ•°ç›®èŒƒå›´æ˜¯ $[1, 3 \times 10^4]$
* $-1000 <= Node.val <= 1000$

---

### é€’å½’ 

ä¸€ä¸ªç®€å•çš„åšæ³•æ˜¯ç›´æ¥é€’å½’æ¥åšï¼šè®¾è®¡ `DFS`  å‡½æ•°ï¼Œä¼ å…¥å½“å‰èŠ‚ç‚¹ `cur`ï¼Œè¿”å›ä»¥è¯¥èŠ‚ç‚¹â€œå¾€ä¸‹â€å»¶ä¼¸æ‰€èƒ½å–å¾—çš„æœ€å¤§è·¯å¾„å’Œã€‚

å³åœ¨ **ä»…ä½¿ç”¨å½“å‰èŠ‚ç‚¹**ã€**ä½¿ç”¨å½“å‰èŠ‚ç‚¹å’Œå·¦å­æ ‘è·¯å¾„** å’Œ **ä½¿ç”¨å½“å‰èŠ‚ç‚¹å’Œå³å­æ ‘è·¯å¾„** ä¸‰è€…ä¸­å–æœ€å¤§å€¼è¿›è¡Œè¿”å›ã€‚

åŒæ—¶åœ¨ `DFS`  è¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬è®¡ç®—ã€Œä»¥å½“å‰èŠ‚ç‚¹ `cur` ä¸ºè·¯å¾„æœ€é«˜ç‚¹ã€æ—¶çš„æœ€å¤§è·¯å¾„å’Œï¼Œå¹¶ç”¨æ­¤æ¥æ›´æ–°å…¨å±€å˜é‡ `ans`ã€‚

å…·ä½“çš„ï¼Œåœ¨ä»¥èŠ‚ç‚¹ `cur` ä¸ºè·¯å¾„æœ€é«˜ç‚¹æ—¶çš„æœ€å¤§è·¯å¾„å’Œï¼Œé¦–å…ˆåŒ…å«å½“å‰èŠ‚ç‚¹æœ¬èº«ï¼ˆ`cur.val`ï¼‰ï¼Œä»¥åŠå¯é€‰çš„å·¦å³èŠ‚ç‚¹è·¯å¾„å’Œï¼ˆ`dfs(cur.left)` å’Œ `dfs(cur.right)`ï¼‰ã€‚å½“å·¦å³èŠ‚ç‚¹è·¯å¾„å’Œä¸ä¸ºè´Ÿæ•°æ—¶ï¼Œè¯´æ˜èƒ½å¤Ÿå¯¹å½“å‰è·¯å¾„èµ·åˆ°æ­£å‘è´¡çŒ®ä½œç”¨ï¼Œå°†å…¶æ·»åŠ åˆ°è·¯å¾„ä¸­ã€‚

Java ä»£ç ï¼š
```Java
class Solution {
    int ans = Integer.MIN_VALUE;
    public int maxPathSum(TreeNode root) {
        dfs(root);
        return ans;
    }
    int dfs(TreeNode root) {
        if (root == null) return 0;
        int left = dfs(root.left), right = dfs(root.right);
        int t = root.val;
        if (left >= 0) t += left;
        if (right >= 0) t += right;
        ans = Math.max(ans, t);
        return Math.max(root.val, Math.max(left, right) + root.val);
    }
}
```
C++ ä»£ç ï¼š
```C++
class Solution {
public:
    int ans = INT_MIN;
    int maxPathSum(TreeNode* root) {
        dfs(root);
        return ans;
    }
    int dfs(TreeNode* root) {
        if (root == nullptr) return 0;
        int left = dfs(root->left), right = dfs(root->right);
        int t = root->val;
        if (left >= 0) t += left;
        if (right >= 0) t += right;
        ans = max(ans, t);
        return max(root->val, max(left, right) + root->val);
    }
};
```
Python ä»£ç ï¼š
```Python
class Solution:
    def maxPathSum(self, root: Optional[TreeNode]) -> int:
        ans = float('-inf')
        def dfs(root):
            nonlocal ans
            if not root: return 0
            l, r = dfs(root.left), dfs(root.right)
            t = root.val
            if l >= 0: t += l
            if r >= 0: t += r
            ans = max(ans, t)
            return max(root.val, max(l, r) + root.val)
        dfs(root)
        return ans
```
TypeScript ä»£ç ï¼š
```TypeScript
function maxPathSum(root: TreeNode | null): number {
    let ans = -0x3f3f3f3f;
    const dfs = function(root: TreeNode | null): number {
        if (root == null) return 0;
        const l = dfs(root.left), r = dfs(root.right);
        let t = root.val;
        if (l >= 0) t += l;
        if (r >= 0) t += r;
        ans = Math.max(ans, t);
        return Math.max(root.val, Math.max(l, r) + root.val);
    };
    dfs(root);
    return ans;
};
```
* æ—¶é—´å¤æ‚åº¦ï¼š$O(n)$
* ç©ºé—´å¤æ‚åº¦ï¼š$O(n)$

---

### æ ‘å½¢ DP

å¦ä¸€ä¸ªåšæ³•æ˜¯ä½¿ç”¨ã€Œæ ‘å½¢ DPã€æ€è·¯æ¥åšã€‚

å°†æŸä¸ªèŠ‚ç‚¹æ‰€åœ¨æœ€ä½³è·¯å¾„æ ¹æ®æ–¹å‘è¿›è¡Œæ‹†åˆ†ï¼š**å¾€å·¦å­èŠ‚ç‚¹è¿›è¡Œå»¶ä¼¸**ã€**å¾€å³å­èŠ‚ç‚¹è¿›è¡Œå»¶ä¼¸** å’Œ **å¾€çˆ¶èŠ‚ç‚¹è¿›è¡Œå»¶ä¼¸**ã€‚

è‹¥èƒ½åˆ†åˆ«æ±‚è§£å‡ºä¸‰ä¸ªæ–¹å‘çš„æœ€å¤§è·¯å¾„å’Œï¼Œä»ä¸­é€‰æ‹©è·¯å¾„å’Œæœ€å¤§ï¼ˆè·¯å¾„å’Œéé›¶ï¼‰çš„ä¸¤ä¸ªæ–¹å‘è¿›è¡Œç´¯åŠ ï¼Œä¾¿æ˜¯å½“å‰èŠ‚ç‚¹çš„æœ€å¤§è·¯å¾„å’Œã€‚

å…·ä½“çš„ï¼Œåˆ›å»ºå“ˆå¸Œè¡¨è®°å½•æŸä¸ªèŠ‚ç‚¹ä¸‰ä¸ªæ–¹å‘çš„è·¯å¾„å’Œæƒ…å†µï¼šèŠ‚ç‚¹å¯¹è±¡ä½œä¸ºå“ˆå¸Œè¡¨çš„é”®ï¼Œä¸‰ä¸ªæ–¹å‘è·¯å¾„å’Œæƒ…å†µä½œä¸ºå€¼ã€‚

å³é”®å€¼å¯¹æ ¼å¼ï¼š`èŠ‚ç‚¹å¯¹è±¡: [çˆ¶èŠ‚ç‚¹æ–¹å‘æœ€å¤§è·¯å¾„å’Œ, å·¦å­èŠ‚ç‚¹æ–¹å‘æœ€å¤§è·¯å¾„å’Œ, å³å­èŠ‚ç‚¹æ–¹å‘æœ€å¤§è·¯å¾„å’Œ]`ã€‚

ç„¶åæ˜¯å¸¸è§„çš„æ ‘å½¢ DP æ±‚è§£æ€è·¯ï¼šç¬¬ä¸€æ¬¡ `DFS`  å…ˆæ±‚è§£ä¸¤ä¸ªâ€œæ–¹å‘å¾€ä¸‹â€çš„æœ€å¤§è·¯å¾„å’Œã€‚ç¬¬äºŒæ¬¡ `DFS`  æ ¹æ® **é¦–æ¬¡ `DFS` å·²ç®—å¥½çš„â€œæ–¹å‘å¾€ä¸‹â€çš„è·¯å¾„å’Œæƒ…å†µ** ä»¥åŠ **æœ¬è½® `DFS`  å·²é€’å½’å¤„ç†å¥½çš„å½“å‰èŠ‚ç‚¹â€œæ–¹å‘å¾€ä¸Šâ€çš„è·¯å¾„å’Œæƒ…å†µ**ï¼Œæ¥æ±‚è§£ å½“å‰èŠ‚ç‚¹å­èŠ‚ç‚¹ çš„â€œæ–¹å‘å¾€ä¸Šâ€è·¯å¾„å’Œæƒ…å†µã€‚

> å¯¹ã€Œæ ‘å½¢ DPã€æ¥è§¦ä¸æ·±çš„åŒå­¦ï¼Œå¯ä»¥çœ‹ [å‰ç½® ğŸ§€](https://leetcode-cn.com/problems/minimum-height-trees/solution/by-ac_oier-7xio/)

Java ä»£ç ï¼š
```Java
class Solution {
    Map<TreeNode, int[]> map = new HashMap<>(); // èŠ‚ç‚¹: [çˆ¶, å·¦, å³]
    public int maxPathSum(TreeNode root) {
        dfs1(root, null);
        dfs2(root, null);
        int ans = Integer.MIN_VALUE;
        for (TreeNode cur : map.keySet()) {
            int t = cur.val;
            int[] info = map.get(cur);
            Arrays.sort(info);
            if (info[2] >= 0) t += info[2];
            if (info[1] >= 0) t += info[1];
            ans = Math.max(ans, t);
        }
        return ans;
    }
    int dfs1(TreeNode cur, TreeNode fa) {
        if (cur == null) return 0;
        int left = dfs1(cur.left, cur), right = dfs1(cur.right, cur);
        int[] info = map.getOrDefault(cur, new int[3]);
        info[1] = left; info[2] = right;
        map.put(cur, info);
        return Math.max(cur.val, cur.val + Math.max(left, right));
    }
    void dfs2(TreeNode cur, TreeNode fa) {
        if (cur == null) return ;
        int[] curInfo = map.get(cur);
        if (cur.left != null) {
            int[] leftInfo = map.get(cur.left);
            leftInfo[0] = Math.max(cur.val, cur.val + Math.max(curInfo[0], curInfo[2]));
        }
        if (cur.right != null) {
            int[] rightInfo = map.get(cur.right);
            rightInfo[0] = Math.max(cur.val, cur.val + Math.max(curInfo[0], curInfo[1]));
        }
        dfs2(cur.left, cur);
        dfs2(cur.right, cur);
    }
}
```
* æ—¶é—´å¤æ‚åº¦ï¼š$O(n)$
* ç©ºé—´å¤æ‚åº¦ï¼š$O(n)$

---

### æœ€å

è¿™æ˜¯æˆ‘ä»¬ã€Œåˆ·ç©¿ LeetCodeã€ç³»åˆ—æ–‡ç« çš„ç¬¬ `No.124` ç¯‡ï¼Œç³»åˆ—å¼€å§‹äº 2021/01/01ï¼Œæˆªæ­¢äºèµ·å§‹æ—¥ LeetCode ä¸Šå…±æœ‰ 1916 é“é¢˜ç›®ï¼Œéƒ¨åˆ†æ˜¯æœ‰é”é¢˜ï¼Œæˆ‘ä»¬å°†å…ˆæŠŠæ‰€æœ‰ä¸å¸¦é”çš„é¢˜ç›®åˆ·å®Œã€‚

åœ¨è¿™ä¸ªç³»åˆ—æ–‡ç« é‡Œé¢ï¼Œé™¤äº†è®²è§£è§£é¢˜æ€è·¯ä»¥å¤–ï¼Œè¿˜ä¼šå°½å¯èƒ½ç»™å‡ºæœ€ä¸ºç®€æ´çš„ä»£ç ã€‚å¦‚æœæ¶‰åŠé€šè§£è¿˜ä¼šç›¸åº”çš„ä»£ç æ¨¡æ¿ã€‚

ä¸ºäº†æ–¹ä¾¿å„ä½åŒå­¦èƒ½å¤Ÿç”µè„‘ä¸Šè¿›è¡Œè°ƒè¯•å’Œæäº¤ä»£ç ï¼Œæˆ‘å»ºç«‹äº†ç›¸å…³çš„ä»“åº“ï¼šhttps://github.com/SharingSource/LogicStack-LeetCode ã€‚

åœ¨ä»“åº“åœ°å€é‡Œï¼Œä½ å¯ä»¥çœ‹åˆ°ç³»åˆ—æ–‡ç« çš„é¢˜è§£é“¾æ¥ã€ç³»åˆ—æ–‡ç« çš„ç›¸åº”ä»£ç ã€LeetCode åŸé¢˜é“¾æ¥å’Œå…¶ä»–ä¼˜é€‰é¢˜è§£ã€‚
