### é¢˜ç›®æè¿°

è¿™æ˜¯ LeetCode ä¸Šçš„ **[2258. é€ƒç¦»ç«ç¾](https://leetcode.cn/problems/escape-the-spreading-fire/solutions/2518985/gong-shui-san-xie-xiang-jie-ru-he-cong-e-458x/)** ï¼Œéš¾åº¦ä¸º **å›°éš¾**ã€‚

Tag : ã€Œå¤šæº BFSã€ã€ã€ŒäºŒåˆ†ã€ã€ã€Œé¢„å¤„ç†ã€



ç»™ä½ ä¸€ä¸ªä¸‹æ ‡ä» `0` å¼€å§‹å¤§å°ä¸º `m x n` çš„äºŒç»´æ•´æ•°æ•°ç»„ `grid`ï¼Œå®ƒè¡¨ç¤ºä¸€ä¸ªç½‘æ ¼å›¾ã€‚

æ¯ä¸ªæ ¼å­ä¸ºä¸‹é¢ $3$ ä¸ªå€¼ä¹‹ä¸€ï¼š

* `0` è¡¨ç¤ºè‰åœ°ã€‚
* `1` è¡¨ç¤ºç€ç«çš„æ ¼å­ã€‚
* `2` è¡¨ç¤ºä¸€åº§å¢™ï¼Œä½ è·Ÿç«éƒ½ä¸èƒ½é€šè¿‡è¿™ä¸ªæ ¼å­ã€‚

ä¸€å¼€å§‹ä½ åœ¨æœ€å·¦ä¸Šè§’çš„æ ¼å­ $(0, 0)$ ï¼Œä½ æƒ³è¦åˆ°è¾¾æœ€å³ä¸‹è§’çš„å®‰å…¨å±‹æ ¼å­ $(m - 1, n - 1)$ ã€‚

æ¯ä¸€åˆ†é’Ÿï¼Œä½ å¯ä»¥ç§»åŠ¨åˆ°ç›¸é‚»çš„è‰åœ°æ ¼å­ã€‚

æ¯æ¬¡ä½ ç§»åŠ¨ä¹‹å ï¼Œç€ç«çš„æ ¼å­ä¼šæ‰©æ•£åˆ°æ‰€æœ‰ä¸æ˜¯å¢™çš„ç›¸é‚»æ ¼å­ã€‚

è¯·ä½ è¿”å›ä½ åœ¨åˆå§‹ä½ç½®å¯ä»¥åœç•™çš„æœ€å¤šåˆ†é’Ÿæ•°ï¼Œä¸”åœç•™å®Œè¿™æ®µæ—¶é—´åä½ è¿˜èƒ½å®‰å…¨åˆ°è¾¾å®‰å…¨å±‹ã€‚

å¦‚æœæ— æ³•å®ç°ï¼Œè¯·ä½ è¿”å› $-1$ã€‚å¦‚æœä¸ç®¡ä½ åœ¨åˆå§‹ä½ç½®åœç•™å¤šä¹…ï¼Œä½ æ€»æ˜¯èƒ½åˆ°è¾¾å®‰å…¨å±‹ï¼Œè¯·ä½ è¿”å› $10^9$ ã€‚

æ³¨æ„ï¼Œå¦‚æœä½ åˆ°è¾¾å®‰å…¨å±‹åï¼Œç«é©¬ä¸Šåˆ°äº†å®‰å…¨å±‹ï¼Œè¿™è§†ä¸ºä½ èƒ½å¤Ÿå®‰å…¨åˆ°è¾¾å®‰å…¨å±‹ã€‚

å¦‚æœä¸¤ä¸ªæ ¼å­æœ‰å…±åŒè¾¹ï¼Œé‚£ä¹ˆå®ƒä»¬ä¸ºç›¸é‚»æ ¼å­ã€‚

ç¤ºä¾‹ 1ï¼š
![](https://assets.leetcode.com/uploads/2022/03/10/ex1new.jpg)

```
è¾“å…¥ï¼šgrid = [[0,2,0,0,0,0,0],[0,0,0,2,2,1,0],[0,2,0,0,1,2,0],[0,0,2,2,2,0,2],[0,0,0,0,0,0,0]]

è¾“å‡ºï¼š3

è§£é‡Šï¼šä¸Šå›¾å±•ç¤ºäº†ä½ åœ¨åˆå§‹ä½ç½®åœç•™ 3 åˆ†é’Ÿåçš„æƒ…å½¢ã€‚
ä½ ä»ç„¶å¯ä»¥å®‰å…¨åˆ°è¾¾å®‰å…¨å±‹ã€‚
åœç•™è¶…è¿‡ 3 åˆ†é’Ÿä¼šè®©ä½ æ— æ³•å®‰å…¨åˆ°è¾¾å®‰å…¨å±‹ã€‚
```
ç¤ºä¾‹ 2ï¼š
![](https://assets.leetcode.com/uploads/2022/03/10/ex2new2.jpg)
```
è¾“å…¥ï¼šgrid = [[0,0,0,0],[0,1,2,0],[0,2,0,0]]

è¾“å‡ºï¼š-1

è§£é‡Šï¼šä¸Šå›¾å±•ç¤ºäº†ä½ é©¬ä¸Šå¼€å§‹æœå®‰å…¨å±‹ç§»åŠ¨çš„æƒ…å½¢ã€‚
ç«ä¼šè”“å»¶åˆ°ä½ å¯ä»¥ç§»åŠ¨çš„æ‰€æœ‰æ ¼å­ï¼Œæ‰€ä»¥æ— æ³•å®‰å…¨åˆ°è¾¾å®‰å…¨å±‹ã€‚
æ‰€ä»¥è¿”å› -1 ã€‚
```
ç¤ºä¾‹ 3ï¼š
![](https://assets.leetcode.com/uploads/2022/03/10/ex3new.jpg)
```
è¾“å…¥ï¼šgrid = [[0,0,0],[2,2,0],[1,2,0]]

è¾“å‡ºï¼š1000000000

è§£é‡Šï¼šä¸Šå›¾å±•ç¤ºäº†åˆå§‹ç½‘æ ¼å›¾ã€‚
æ³¨æ„ï¼Œç”±äºç«è¢«å¢™å›´äº†èµ·æ¥ï¼Œæ‰€ä»¥æ— è®ºå¦‚ä½•ä½ éƒ½èƒ½å®‰å…¨åˆ°è¾¾å®‰å…¨å±‹ã€‚
æ‰€ä»¥è¿”å› 109 ã€‚
```

æç¤ºï¼š
* $m = grid.length$
* $n = grid[i].length$
* $2 <= m, n <= 300$
* $4 <= m \times n <= 2 \times 10^4$
* `grid[i][j]` æ˜¯ `0`ï¼Œ`1` æˆ–è€… `2`ã€‚
* $grid[0][0] = grid[m - 1][n - 1] = 0$

---

### äºŒåˆ† + BFS

ç«åŠ¿è”“å»¶æ˜¯ä¸€ä¸ªå›ºå®šçš„è¿‡ç¨‹ï¼Œåªæœ‰äººå‘˜ç§»åŠ¨éœ€è¦å†³ç­–ã€‚

å‡è®¾äººå‘˜æœ€æ™šåœ¨ $t$ ç§’åå‡ºå‘ï¼Œä»èƒ½åˆ°è¾¾å®‰å…¨å±‹ï¼Œè¯´æ˜äººå‘˜å¯¹é€ƒèµ°è·¯çº¿çš„è®¿é—®ï¼Œè¦æ¯”ç«åŠ¿æ›´å¿«ã€‚é‚£ä¹ˆäººå‘˜åœ¨æ›´æ—©çš„æ—¶é—´ç‚¹ï¼ˆ$[0, t - 1]$ ç§’åï¼‰å‡ºå‘ï¼Œå¿…ç„¶ä»èƒ½æŒ‰ç…§åŸå®šè·¯çº¿åˆ°è¾¾å®‰å…¨å±‹ï¼ˆç«åŠ¿å¯¹è·¯å¾„çš„å½±å“ä¸å˜ï¼‰ã€‚

å› æ­¤ï¼Œåœ¨ä»¥ $t$ ä¸ºåˆ†å‰²ç‚¹çš„ï¼ˆæ­£æ•´æ•°ï¼‰æ•°è½´ä¸Šï¼Œå…·æœ‰äºŒæ®µæ€§ï¼Œå¯è¿ç”¨ã€ŒäºŒåˆ†ã€æ±‚åˆ†å‰²ç‚¹ã€‚

å‡è®¾å­˜åœ¨æŸä¸ªåˆ¤å®šå‡½æ•° `check`ï¼Œç”¨äºæ£€æŸ¥äººå‘˜åœ¨ $x$ ç§’åå‡ºå‘èƒ½å¦åˆ°è¾¾å®‰å…¨å±‹ï¼Œé‚£ä¹ˆå¯çŸ¥ï¼š

* å½“å®é™…å»¶è¿Ÿå‡ºå‘çš„ç§’æ•°ï¼Œå°äºç­‰äº $t$ ç§’ï¼Œå¿…ç„¶èƒ½å®‰å…¨åˆ°è¾¾
* å½“å®é™…å»¶è¿Ÿå‡ºå‘çš„æè¿°ï¼Œè¶…è¿‡ $t$ ç§’ï¼Œå¿…ç„¶ä¸èƒ½å®‰å…¨åˆ°è¾¾

åœ¨äººå‘˜ç§»åŠ¨è·¯çº¿ä¸­ï¼Œâ€œå›å¤´è·¯â€æ˜¯æ²¡æœ‰æ„ä¹‰çš„ï¼Œå› æ­¤äººå‘˜å¯¹æ¯ä¸ªç‚¹çš„è®¿é—®æ¬¡æ•°æœ€å¤šä¸ºä¸€æ¬¡ã€‚åŒæ—¶ï¼Œä¸è€ƒè™‘å¢™çš„é˜»æ‹¦ï¼Œç«åŠ¿ä¹Ÿæœ€å¤šåœ¨ä¸è¶…è¿‡æ£‹ç›˜å¤§å°çš„æ—¶é—´å†…å®Œå…¨è”“å»¶ã€‚

è¿™æŒ‡å¯¼æˆ‘ä»¬æœ€å¤§å»¶è¿Ÿå‡ºå‘æ—¶é—´ä¸ä¼šè¶…è¿‡ $n \times m$ï¼Œå¯åœ¨ $[0, n \times m]$ å€¼åŸŸå†…è¿›è¡ŒäºŒåˆ†ã€‚

æ¥ä¸‹æ¥ï¼Œè€ƒè™‘å¦‚ä½•å®ç° `check` å‡½æ•°ï¼Œå‡½æ•°å…¥å‚ä¸ºå»¶è¿Ÿå‡ºå‘ç§’æ•°  $t$ï¼Œè¿”å›å€¼ä¸ºå»¶è¿Ÿå‡ºå‘åèƒ½å¦åˆ°è¾¾å®‰å…¨å±‹ã€‚

é¦–å…ˆï¼Œå¯¹äºæ™®é€šä½ç½®ï¼Œå¦‚æœç«åŠ¿å’Œäººå‘˜åŒæ—¶åˆ°è¾¾ï¼Œæ˜¯ä¸å…è®¸çš„ï¼Œè€Œå®‰å…¨å±‹ $(n - 1, m - 1)$ ä½ç½®çš„åŒæ—¶åˆ°è¾¾ï¼Œæ˜¯å…è®¸çš„ã€‚

å› æ­¤ï¼Œæˆ‘ä»¬éœ€è¦ä½¿ç”¨ä¸¤ä¸ªäºŒç»´æ•°ç»„ `fg` å’Œ `pg` åˆ†åˆ«è®°å½•ã€Œç«åŠ¿ã€å’Œã€Œäººå‘˜ã€åˆ°è¾¾æŸä¸ªä½ç½®çš„æœ€æ—©æ—¶é—´ã€‚

1. åˆ›å»ºç”¨äºæ¨¡æ‹Ÿç«åŠ¿è”“å»¶çš„é˜Ÿåˆ— `fire`ï¼Œéå†ç½‘æ ¼ï¼Œå°†ç«æºä½ç½®è¿›è¡Œå…¥é˜Ÿï¼Œæ›´æ–°ç«æºä½ç½® $fg[i][j] = 1$ï¼Œè¡¨ç¤ºç«åŠ¿åœ¨ç¬¬ä¸€ç§’æ—¶æœ€æ—©å‡ºç°åœ¨æ­¤å¤„ï¼›

2. è¿ç”¨ `BFS`ï¼Œæ¨¡æ‹Ÿ $t$ ç§’çš„ç«åŠ¿è”“å»¶ï¼Œç«åŠ¿åœ¨è¿™ $t$ ç§’å†…æ‰€è”“å»¶åˆ°çš„æ–°ä½ç½®ï¼Œå‡çœ‹ä½œä¸ºèµ·å§‹ç«æºï¼Œå³æœ‰ $fg[i][j] = 1$ã€‚

   è‹¥æ‰§è¡Œå®Œ $t$ ç§’åï¼Œç«åŠ¿å·²è”“å»¶åˆ°äººå‘˜èµ·å§‹ä½ç½® $(0, 0)$ï¼Œé‚£ä¹ˆå»¶è¿Ÿ $t$ ç§’å‡ºå‘ä¸å¯è¡Œï¼Œç›´æ¥è¿”å› `False`ï¼›

3. åˆ›å»ºç”¨äºæ¨¡æ‹Ÿäººå‘˜ç§»åŠ¨çš„é˜Ÿåˆ— `people`ï¼Œå°†èµ·å§‹ä½ç½® $(0, 0)$ è¿›è¡Œå…¥é˜Ÿï¼Œæ›´æ–° $pg[0][0] = 1$ã€‚

   è¿ç”¨ `BFS`ï¼ŒæŒ‰ç…§ã€Œå…ˆç«åäººã€çš„æ–¹å¼ï¼ŒåŒæ­¥æ¨¡æ‹Ÿã€Œç«åŠ¿è”“å»¶ã€å’Œã€Œäººå‘˜ç§»åŠ¨ã€è¿‡ç¨‹ã€‚æ™®é€šä½ç½®ï¼Œåªè¦ç«åŠ¿è”“å»¶åˆ°ï¼Œé‚£ä¹ˆäººå°†æ— æ³•ç§»åŠ¨åˆ°æ­¤å¤„ï¼›å®‰å…¨å±‹ä½ç½®ï¼Œéœ€è¦åˆ¤æ–­æ˜¯å¦ä¸ç«åŠ¿åŒä¸€æ—¶åˆ»åˆ°è¾¾ã€‚


ä¸ºäº†æ–¹ä¾¿ï¼Œå°†ã€Œç«åŠ¿è”“å»¶ã€å’Œã€Œäººå‘˜ç§»åŠ¨ã€ç»Ÿä¸€æˆ `update` æ“ä½œï¼Œå…¥å‚åŒ…æ‹¬å½“å‰é˜Ÿåˆ— `d`ï¼Œæ ‡è¯†ä½ `isFire`ï¼Œä»¥åŠç§»åŠ¨åç§»é‡ `offset`ã€‚

åœ¨è¿›è¡Œ $t$ ç§’çš„ç«åŠ¿è”“å»¶æ—¶ï¼Œè°ƒç”¨ $t$ æ¬¡çš„ `update(fire, true, 0)`ã€‚åœ¨ç«åŠ¿å’Œäººå‘˜åŒæ­¥æ¨¡æ‹Ÿæ—¶ï¼Œåˆ†åˆ«è°ƒç”¨ `update(fire, true, 1)` å’Œ `update(people, false, 1)`ã€‚

ä½¿ç”¨ç¤ºä¾‹ $1$ æ¥ä¸¾ä¸ª ğŸŒ°ï¼š

![image.png](https://pic.leetcode.cn/1699489752-IjzDOL-image.png)

![image.png](https://pic.leetcode.cn/1699489775-ECRlVp-image.png)

Java ä»£ç ï¼š

```Java
class Solution {
    int[][] dirs = new int[][]{{0,1}, {0,-1}, {1,0}, {-1,0}};
    int n, m;
    boolean ok;
    int[][] g, fg, pg;
    public int maximumMinutes(int[][] grid) {
        g = grid;
        n = g.length; m = g[0].length;
        fg = new int[n][m]; pg = new int[n][m];
        if (!check(0)) return -1;
        int l = 0, r = n * m;
        while (l < r) {
            int mid = l + r + 1 >> 1;
            if (check(mid)) l = mid;
            else r = mid - 1;
        }
        return r == m * n ? (int)1e9 : r;
    }
    boolean check(int t) {
        ok = false;
        Deque<int[]> frie = new ArrayDeque<>();
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                fg[i][j] = pg[i][j] = 0;
                if (g[i][j] == 1) {
                    fg[i][j] = 1;
                    frie.addLast(new int[]{i, j});
                }
            }
        }
        while(t-- > 0) update(frie, true, 0);  // å…ˆæ‰§è¡Œ t ç§’çš„ç«åŠ¿è”“å»¶
        if (fg[0][0] != 0) return false;
        Deque<int[]> people = new ArrayDeque<>();
        pg[0][0] = 1;
        people.addLast(new int[]{0, 0});
        while (!people.isEmpty()) {
            // å…ˆç«åäºº, åŒæ­¥è¿›è¡Œ
            update(frie, true, 1);
            update(people, false, 1);
            if (ok) return true;
        }
        return false;
    }
    void update(Deque<int[]> deque, boolean isFire, int offset) {
        int sz = deque.size();
        while (sz-- > 0) {
            int[] info = deque.pollFirst();
            int x = info[0], y = info[1];
            for (int[] dir : dirs) {
                int nx = x + dir[0], ny = y + dir[1];
                if (nx < 0 || nx >= n || ny < 0 || ny >= m) continue;
                if (g[nx][ny] == 2) continue;
                if (isFire) {
                    if (fg[nx][ny] != 0) continue;
                    fg[nx][ny] = fg[x][y] + offset;
                } else {
                    if (nx == n - 1 && ny == m - 1 && (fg[nx][ny] == 0 || fg[nx][ny] == pg[x][y] + offset)) ok = true;  // ç«å°šæœªåˆ°è¾¾ æˆ– åŒæ—¶åˆ°è¾¾
                    if (fg[nx][ny] != 0 || pg[nx][ny] != 0) continue;
                    pg[nx][ny] = pg[x][y] + offset;
                }
                deque.addLast(new int[]{nx, ny});
            }
        }
    }
}
```
C++ ä»£ç ï¼š
```C++
class Solution {
public:
    vector<vector<int>> dirs = {{0,1}, {0,-1}, {1,0}, {-1,0}};
    int n, m;
    bool ok;
    vector<vector<int>> g, fg, pg;
    int maximumMinutes(vector<vector<int>>& grid) {
        g = grid;
        n = g.size(); m = g[0].size();
        fg = vector<vector<int>>(n, vector<int>(m, 0)), pg = vector<vector<int>>(n, vector<int>(m, 0));
        if (!check(0)) return -1;
        int l = 0, r = n * m;
        while (l < r) {
            int mid = l + r + 1 >> 1;
            if (check(mid)) l = mid;
            else r = mid - 1;
        }
        return r == n * m ? (int)1e9 : r;
    }
    bool check(int t) {
        ok = false;
        deque<vector<int>> frie;   
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                fg[i][j] = pg[i][j] = 0;
                if (g[i][j] == 1) {
                    fg[i][j] = 1;
                    frie.push_back({i, j});
                }
            }
        }
        while (t-- > 0) update(frie, true, 0);
        if (fg[0][0] != 0) return false;
        deque<vector<int>> people;
        pg[0][0] = 1;
        people.push_back({0, 0});
        while (!people.empty()) {
            update(frie, true, 1);
            update(people, false, 1);
            if (ok) return true;
        }
        return false;
    }
    void update(deque<vector<int>>& deque, bool isFire, int offset) {
        int sz = deque.size();
        while (sz-- > 0) {
            vector<int> info = deque.front();
            deque.pop_front();
            int x = info[0], y = info[1];
            for (vector<int> dir : dirs) {
                int nx = x + dir[0], ny = y + dir[1];
                if (nx < 0 || nx >= n || ny < 0 || ny >= m) continue;
                if (g[nx][ny] == 2) continue;
                if (isFire) {
                    if (fg[nx][ny] != 0) continue;                    
                    fg[nx][ny] = fg[x][y] + offset;
                } else {
                    if (nx == n - 1 && ny == m - 1 && (fg[nx][ny] == 0 || fg[nx][ny] == pg[x][y] + offset)) ok = true;
                    if (fg[nx][ny] != 0 || pg[nx][ny] != 0) continue;
                    pg[nx][ny] = pg[x][y] + offset;
                }
                deque.push_back({nx, ny});
            }
        }
    }
};
```
Python ä»£ç ï¼š
```Python
from collections import deque

class Solution:
    def maximumMinutes(self, grid: List[List[int]]) -> int:
        dirs = [(0,1),(0,-1),(1,0),(-1,0)]
        g = grid
        n, m = len(g), len(g[0])
        fg, pg, ok = None, None, False

        def update(d, isFire, offset):
            nonlocal ok
            for _ in range(len(d)):
                x, y = d.popleft()
                for dx, dy in dirs:
                    nx, ny = x + dx, y + dy
                    if nx < 0 or nx >= n or ny < 0 or ny >= m: continue
                    if g[nx][ny] == 2: continue
                    if isFire:
                        if fg[nx][ny] != 0: continue
                        fg[nx][ny] = fg[x][y] + offset
                    else:
                        if nx == n - 1 and ny == m - 1 and (fg[nx][ny] == 0 or fg[nx][ny] == pg[x][y] + offset): ok = True
                        if fg[nx][ny] != 0 or pg[nx][ny] != 0: continue
                        pg[nx][ny] = pg[x][y] + offset
                    d.append((nx, ny))

        def check(t):
            nonlocal pg, fg, ok
            ok = False
            pg = [[0] * m for _ in range(n)]
            fg = [[g[i][j] == 1 for j in range(m)] for i in range(n)]
            fire = deque([(i, j) for i, j in product(range(n), range(m)) if g[i][j] == 1])
            for _ in range(t): update(fire, True, 0)
            if fg[0][0] != 0: return False
            people = deque()
            pg[0][0] = 1
            people.append((0, 0))
            while people:
                update(fire, True, 1)
                update(people, False, 1)
                if ok: return True
            return False

        if not check(0): return -1
        l, r = 0, n * m
        while l < r:
            mid = l + r + 1 >> 1
            if check(mid): l = mid
            else: r = mid - 1
        return int(1e9) if r == n * m else r
```
TypeScript ä»£ç ï¼š
```TypeScript
function maximumMinutes(grid: number[][]): number {
    const dirs = [[0,1],[0,-1],[1,0],[-1,0]];
    const g = grid;
    const n = g.length, m = g[0].length;
    const fg = Array.from({length: n}, () => Array(m).fill(0)), pg = Array.from({length: n}, () => Array(m).fill(0));
    let ok = false;
    const update = function(d: number[][], isFire: boolean, offset: number) {
        let sz = d.length;
        while (sz-- > 0) {
            const info = d.shift();
            const x = info[0], y = info[1];
            for (let di of dirs) {
                const nx = x + di[0], ny = y + di[1];
                if (nx < 0 || nx >= n || ny < 0 || ny >= m) continue;
                if (g[nx][ny] == 2) continue;
                if (isFire) {
                    if (fg[nx][ny] != 0) continue;
                    fg[nx][ny] = fg[x][y] + offset;
                } else {
                    if (nx == n - 1 && ny == m - 1 && (fg[nx][ny] == 0 || fg[nx][ny] == pg[x][y] + offset)) ok = true;
                    if (fg[nx][ny] != 0 || pg[nx][ny] != 0) continue;
                    pg[nx][ny] = pg[x][y] + offset;
                }
                d.push([nx, ny]);
            }
        }
    }
    const check = function(t: number): boolean {
        ok = false
        const fire = new Array()
        for (let i = 0; i < n; i++) {
            for (let j = 0; j < m; j++) {
                fg[i][j] = pg[i][j] = 0;
                if (g[i][j] == 1) {
                    fg[i][j] = 1;
                    fire.push([i, j]);
                }
            }
        }
        while (t-- > 0) update(fire, true, 0);
        if (fg[0][0] != 0) return false;
        const people = new Array();
        pg[0][0] = 1;
        people.push([0, 0]);
        while (people.length != 0) {
            update(fire, true, 1);
            update(people, false, 1);
            if (ok) return true;
        }
        return false;
    }
    if (!check(0)) return -1;
    let l = 0, r = n * m;
    while (l < r) {
        const mid = l + r + 1 >> 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return r == n * m ? 1e9 : r;
};
```
* æ—¶é—´å¤æ‚åº¦ï¼šåœ¨å€¼åŸŸ $[0, n \times m]$ èŒƒå›´å†…è¿›è¡ŒäºŒåˆ†ï¼ŒäºŒåˆ† `check` çš„ `BFS`  å®ç°å¤æ‚åº¦ä¸º $O(n \times m)$ã€‚æ•´ä½“å¤æ‚åº¦ä¸º $O(nm \log{nm})$
* ç©ºé—´å¤æ‚åº¦ï¼š$O(n \times m)$

---

### BFS + åˆ†ç±»è®¨è®º

ç»è¿‡ä¸Šè¿°è§£æ³•ï¼Œæˆ‘ä»¬å‘ç°å­˜åœ¨å¤§é‡é‡å¤è®¡ç®—ï¼šä¾‹å¦‚æ¯æ¬¡å”¯ä¸€ç¡®å®šçš„â€œç«åŠ¿è”“å»¶â€è¿‡ç¨‹ï¼Œä»¥åŠæ¯æ¬¡æ ¹æ®æœ€æ–°èµ·å§‹ç«åŠ¿ï¼ˆç”±å»¶è¿Ÿå‡ºå‘æ—¶é—´ $t$ æ‰€å†³å®šï¼‰è¿›è¡Œçš„â€œäººå‘˜ç§»åŠ¨â€è¿‡ç¨‹ï¼Œéƒ½æ˜¯ä¸å¿…è¦çš„ï¼Œå¯é€šè¿‡æ¯”è¾ƒåŒæ–¹åˆ°è¾¾æ—¶é—´æ¥æ±‚è§£ã€‚

å…·ä½“çš„ï¼Œè¿˜æ˜¯ç”¨ `fg` å’Œ `pg`ï¼Œåˆ†åˆ«é¢„å¤„ç†å‡ºã€Œç«åŠ¿ã€å’Œã€Œäººå‘˜ã€åˆ°è¾¾æ¯ä¸ªç½‘æ ¼çš„æœ€æ—©æ—¶é—´ã€‚å…¶ä¸­ç«åŠ¿è”“å»¶å”¯ä¸€ç¡®å®šï¼Œè€Œäººå‘˜çš„é¢„å¤„ç†æ˜¯åœ¨ä¸è€ƒè™‘ç«åŠ¿çš„æƒ…å†µä¸‹è¿›è¡Œã€‚

æ ¹æ® $f = fg[n-1][m-1]$ å’Œ $p = pg[n-1][m-1]$ è¿›è¡Œåˆ†æƒ…å†µè®¨è®ºï¼š

* è‹¥ $p = 0$ï¼šäººä¸å®‰å…¨å±‹ä¸è¿é€šï¼Œè¿”å› $-1$ï¼›

* è‹¥ $f = 0$ï¼šç«ä¸å®‰å…¨å±‹ä¸è¿é€šï¼ŒåŒæ—¶ä¸Šè¿°æ¡ä»¶ä¸æ»¡è¶³ï¼ˆ$p \neq 0$ï¼‰ï¼Œå³äººä¸å®‰å…¨å±‹æ˜¯è”é€š ï¼Œè¿”å› $1e9$ï¼›

* è‹¥ $f < p$ï¼šç«å’Œäººéƒ½èƒ½åˆ°è¾¾å®‰å…¨å±‹ã€‚å³ä½¿ä¸è€ƒè™‘äººå‘˜ä¸­é€”è¢«ç«å½±å“ï¼ˆäººå‘˜å¯èƒ½æ— æ³•æŒ‰ç…§æœ€ä½³è·¯çº¿å‰å¾€å®‰å…¨å±‹ï¼‰çš„æƒ…å†µä¸‹ï¼Œç«ä¹Ÿæ¯”äººè¦æ›´æ—©åˆ°è¾¾å®‰å…¨å±‹ï¼Œè¿”å› $-1$ï¼›

* è‹¥ $f \geqslant p$ï¼šç†æƒ³æƒ…å†µä¸‹ï¼Œäººæ¯”ç«æ›´æ—©åˆ°è¾¾å®‰å…¨å±‹ï¼Œä½†å­˜åœ¨ã€Œäººç«åŒæ—¶åˆ°è¾¾ã€ã€ã€Œäººå‘˜ä¸­é€”è¢«çƒ§ã€æˆ–ã€Œé€šè·¯è¢«ç«æ‹¦æˆªã€ç­‰é—®é¢˜ï¼Œéœ€è¦è¿›ä¸€æ­¥åˆ†æƒ…å†µè®¨è®ºï¼š

  ä¸éš¾å‘ç°ï¼Œç”±äºå®‰å…¨å±‹çš„ä½äº $(n - 1, m - 1)$ï¼Œäººå‘˜åªèƒ½ä» $(n - 1, m - 2)$ æˆ– $(n - 2, m - 1)$ ä¸¤ä¸ªä½ç½®ä¹‹ä¸€åˆ°è¾¾å®‰å…¨å±‹ï¼ˆè¿™ä¸¤ä¸ªå±äºæ™®é€šä½ç½®ï¼Œä¸å…è®¸äººå’Œç«åŒæ—¶åˆ°è¾¾ï¼‰ï¼Œå› æ­¤å¯ä»¥å°†ã€Œå¯¹ç‰¹æ®Šä½ç½®å®‰å…¨å±‹ã€çš„è®¨è®ºè½¬ä¸ºã€Œå¯¹æ™®é€šä½ç½®ã€çš„è®¨è®ºï¼š

  * è‹¥ $pg[n - 1][m - 2] \neq 0$ï¼Œäººä¸è¯¥ä½ç½®è”é€šï¼Œä¸” $f - p + pg[n - 1][m - 2] < fg[n - 1][m - 2]$ï¼Œäººæ¯”ç«æ›´æ—©åˆ°è¾¾è¯¥ä½ç½®ï¼Œè¿”å› $f - p$ï¼›
  * è‹¥ $pg[n - 2][m - 1] \neq 0$ï¼Œäººä¸è¯¥ä½ç½®è”é€šï¼Œä¸” $f - p + pg[n - 2][m - 1] < fg[n - 2][m - 1]$ï¼Œäººæ¯”ç«æ›´æ—©åˆ°è¾¾è¯¥ä½ç½®ï¼Œè¿”å› $f - p$ï¼›
  * å¦åˆ™ï¼Œè¯´æ˜å»¶è¿Ÿ $f - p$ ç§’å‡ºå‘ï¼Œå”¯äºŒçš„é€šè·¯ä¼šè¢«ç«æå‰æ‹¦æˆªï¼Œéœ€è¦æ—©ä¸€ç§’å‡ºå‘ï¼Œè¿”å› $f - p - 1$;

Java ä»£ç ï¼š
```Java
class Solution {
    int[][] dirs = new int[][]{{0,1}, {0,-1}, {1,0}, {-1,0}};
    int[][] g;
    int n, m;
    public int maximumMinutes(int[][] grid) {
        g = grid;
        n = g.length; m = g[0].length;
        int[][] fg = new int[n][m], pg = new int[n][m];
        Deque<int[]> fire = new ArrayDeque<>();
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (g[i][j] == 1) {
                    fg[i][j] = 1;
                    fire.addLast(new int[]{i, j});
                }
            }
        }
        bfs(fire, fg);
        Deque<int[]> people = new ArrayDeque<>();
        people.addLast(new int[]{0, 0});
        pg[0][0] = 1;
        bfs(people, pg);
        int p = pg[n - 1][m - 1], f = fg[n - 1][m - 1], ans = f - p;
        if (p == 0) return -1;
        if (f == 0) return (int)1e9;
        if (p > f) return -1;
        if (pg[n - 1][m - 2] != 0 && ans + pg[n - 1][m - 2] < fg[n - 1][m - 2]) return ans;
        if (pg[n - 2][m - 1] != 0 && ans + pg[n - 2][m - 1] < fg[n - 2][m - 1]) return ans;
        return ans - 1;
    }
    void bfs(Deque<int[]> d, int[][] time) {
        while (!d.isEmpty()) {
            int[] info = d.pollFirst();
            int x = info[0], y = info[1];
            for (int[] dir : dirs) {
                int nx = x + dir[0], ny = y + dir[1];
                if (nx < 0 || nx >= n || ny < 0 || ny >= m) continue;
                if (g[nx][ny] == 2) continue;
                if (time[nx][ny] != 0) continue;
                time[nx][ny] = time[x][y] + 1;
                d.addLast(new int[]{nx, ny});
            }
        }
    }
}
```
C++ ä»£ç ï¼š
```C++
class Solution {
public:
    vector<vector<int>> dirs = {{0,1}, {0,-1}, {1,0}, {-1,0}};
    vector<vector<int>> g;
    int n, m;
    int maximumMinutes(vector<vector<int>>& grid) {
        g = grid;
        n = g.size(); m = g[0].size();
        vector<vector<int>> fg = vector<vector<int>>(n, vector<int>(m, 0)), pg = vector<vector<int>>(n, vector<int>(m, 0));
        deque<pair<int, int>> fire;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (g[i][j] == 1) {
                    fg[i][j] = 1;
                    fire.push_back({i, j});
                }
            }
        }
        bfs(fire, fg);
        deque<pair<int, int>> people;
        people.push_back({0, 0});
        pg[0][0] = 1;
        bfs(people, pg);
        int p = pg[n - 1][m - 1], f = fg[n - 1][m - 1], ans = f - p;
        if (p == 0) return -1;
        if (f == 0) return (int)1e9;
        if (p > f) return -1;
        if (pg[n - 1][m - 2] != 0 && ans + pg[n - 1][m - 2] < fg[n - 1][m - 2]) return ans;
        if (pg[n - 2][m - 1] != 0 && ans + pg[n - 2][m - 1] < fg[n - 2][m - 1]) return ans;
        return ans - 1;
    }
    void bfs(deque<pair<int, int>>& d, vector<vector<int>>& time) {
        while (!d.empty()) {
            pair<int, int> info = d.front();
            d.pop_front();
            int x = info.first, y = info.second;
            for (vector<int> dir : dirs) {
                int nx = x + dir[0], ny = y + dir[1];
                if (nx < 0 || nx >= n || ny < 0 || ny >= m) continue;
                if (g[nx][ny] == 2) continue;
                if (time[nx][ny] != 0) continue;
                time[nx][ny] = time[x][y] + 1;
                d.push_back({nx, ny});
            }
        }
    }
};
```
Python ä»£ç ï¼š
```Python
from collections import deque

class Solution:
    def maximumMinutes(self, grid: List[List[int]]) -> int:
        dirs = [(0,1), (0,-1), (1,0), (-1,0)]
        g = grid
        n, m = len(g), len(g[0])

        def bfs(d, tn):
            while d:
                x, y = d.popleft()
                for dx, dy in dirs:
                    nx, ny = x + dx, y + dy
                    if nx < 0 or nx >= n or ny < 0 or ny >= m: continue
                    if g[nx][ny] == 2 or tn[nx][ny]: continue
                    tn[nx][ny] = tn[x][y] + 1
                    d.append((nx, ny))

        fg = [[g[i][j] == 1 for j in range(m)] for i in range(n)]
        fire = deque([(i, j) for i, j in product(range(n), range(m)) if g[i][j] == 1])
        bfs(fire, fg)
        pg = [[0] * m for _ in range(n)]
        pg[0][0] = 1
        people = deque([(0, 0)])
        bfs(people, pg)

        p, f = pg[-1][-1], fg[-1][-1]
        ans = f - p
        if p == 0: return -1
        if f == 0: return int(1e9)
        if p > f: return -1
        if pg[-1][-2] != 0 and ans + pg[-1][-2] < fg[-1][-2]: return ans
        if pg[-2][-1] != 0 and ans + pg[-2][-1] < fg[-2][-1]: return ans
        return ans - 1
```
TypeScript ä»£ç ï¼š
```TypeScript
function maximumMinutes(grid: number[][]): number {
    const g = grid;
    const n = g.length, m = g[0].length;
    const dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];
    const bfs = function (d: number[][], time: number[][]): void {
        while (d.length > 0) {
            const info = d.shift() as number[];
            const x = info[0], y = info[1];
            for (const dir of dirs) {
                const nx = x + dir[0], ny = y + dir[1];
                if (nx < 0 || nx >= n || ny < 0 || ny >= m) continue;
                if (g[nx][ny] == 2) continue;
                if (time[nx][ny] != 0) continue;
                time[nx][ny] = time[x][y] + 1;
                d.push([nx, ny]);
            }
        }
    }
    const fg = Array.from({ length: n }, () => Array(m).fill(0));
    const pg = Array.from({ length: n }, () => Array(m).fill(0));
    const fire = [];
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < m; j++) {
            if (g[i][j] == 1) {
                fg[i][j] = 1;
                fire.push([i, j]);
            }
        }
    }
    bfs(fire, fg);
    const people = [];
    people.push([0, 0]);
    pg[0][0] = 1;
    bfs(people, pg);
    const p = pg[n - 1][m - 1], f = fg[n - 1][m - 1], ans = f - p;
    if (p == 0) return -1;
    if (f == 0) return 1e9;
    if (p > f) return -1;
    if (pg[n - 1][m - 2] != 0 && ans + pg[n - 1][m - 2] < fg[n - 1][m - 2]) return ans;
    if (pg[n - 2][m - 1] != 0 && ans + pg[n - 2][m - 1] < fg[n - 2][m - 1]) return ans;
    return ans - 1;
};
```
* æ—¶é—´å¤æ‚åº¦ï¼š$O(n \times m)$
* ç©ºé—´å¤æ‚åº¦ï¼š$O(n \times m)$

---

### æœ€å

è¿™æ˜¯æˆ‘ä»¬ã€Œåˆ·ç©¿ LeetCodeã€ç³»åˆ—æ–‡ç« çš„ç¬¬ `No.2258` ç¯‡ï¼Œç³»åˆ—å¼€å§‹äº 2021/01/01ï¼Œæˆªæ­¢äºèµ·å§‹æ—¥ LeetCode ä¸Šå…±æœ‰ 1916 é“é¢˜ç›®ï¼Œéƒ¨åˆ†æ˜¯æœ‰é”é¢˜ï¼Œæˆ‘ä»¬å°†å…ˆæŠŠæ‰€æœ‰ä¸å¸¦é”çš„é¢˜ç›®åˆ·å®Œã€‚

åœ¨è¿™ä¸ªç³»åˆ—æ–‡ç« é‡Œé¢ï¼Œé™¤äº†è®²è§£è§£é¢˜æ€è·¯ä»¥å¤–ï¼Œè¿˜ä¼šå°½å¯èƒ½ç»™å‡ºæœ€ä¸ºç®€æ´çš„ä»£ç ã€‚å¦‚æœæ¶‰åŠé€šè§£è¿˜ä¼šç›¸åº”çš„ä»£ç æ¨¡æ¿ã€‚

ä¸ºäº†æ–¹ä¾¿å„ä½åŒå­¦èƒ½å¤Ÿç”µè„‘ä¸Šè¿›è¡Œè°ƒè¯•å’Œæäº¤ä»£ç ï¼Œæˆ‘å»ºç«‹äº†ç›¸å…³çš„ä»“åº“ï¼šhttps://github.com/SharingSource/LogicStack-LeetCode ã€‚

åœ¨ä»“åº“åœ°å€é‡Œï¼Œä½ å¯ä»¥çœ‹åˆ°ç³»åˆ—æ–‡ç« çš„é¢˜è§£é“¾æ¥ã€ç³»åˆ—æ–‡ç« çš„ç›¸åº”ä»£ç ã€LeetCode åŸé¢˜é“¾æ¥å’Œå…¶ä»–ä¼˜é€‰é¢˜è§£ã€‚

