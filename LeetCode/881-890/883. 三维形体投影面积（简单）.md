### 题目描述

这是 LeetCode 上的 **[883. 三维形体投影面积](https://leetcode-cn.com/problems/projection-area-of-3d-shapes/solution/by-ac_oier-r6hj/)** ，难度为 **简单**。

Tag : 「模拟」



在 $n \times n$ 的网格 `grid` 中，我们放置了一些与 `x`，`y`，`z` 三轴对齐的 $1 \times 1 \times 1$ 立方体。

每个值 $v = grid[i][j]$ 表示 $v$ 个正方体叠放在单元格 $(i, j)$ 上。

现在，我们查看这些立方体在 `xy`、`yz` 和 `zx` 平面上的投影。

投影就像影子，将三维形体映射到一个二维平面上。

从顶部、前面和侧面看立方体时，我们会看到“影子”。

返回所有三个投影的总面积。

示例 1：

![](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/02/shadow.png)

```
输入：[[1,2],[3,4]]

输出：17

解释：这里有该形体在三个轴对齐平面上的三个投影(“阴影部分”)。
```
示例 2:
```
输入：grid = [[2]]

输出：5
```
示例 3：
```
输入：[[1,0],[0,2]]

输出：8
```

提示：
* $n = grid.length = grid[i].length$
* $1 <= n <= 50$
* $0 <= grid[i][j] <= 50$

---

### 模拟

根据题意进行模拟即可，使用三个变量分别统计三视图的阴影面积：

* `ans1`：统计俯视图的面积，共有 $n * n$ 个位置需要被统计，当任意格子 $g[i][j] > 0$，阴影面积加一；
* `ans2`：统计左视图的面积，共有 $n$ 行需要被统计，每一行对 `ans2` 的贡献为该行的最大高度；
* `ans3`：统计主视图的面积，共有 $n$ 列需要被统计，每一列对 `ans3` 的贡献为该列的最大高度。

Java 代码：
```Java
class Solution {
    public int projectionArea(int[][] g) {
        int n = g.length, ans1 = 0, ans2 = 0, ans3 = 0;
        for (int i = 0; i < n; i++) {
            int a = 0, b = 0;
            for (int j = 0; j < n; j++) {
                if (g[i][j] > 0) ans1++;
                a = Math.max(a, g[i][j]);
                b = Math.max(b, g[j][i]);
            }
            ans2 += a; ans3 += b;
        }
        return ans1 + ans2 + ans3;
    }
}
```
C++ 代码：
```C++
class Solution {
public:
    int projectionArea(vector<vector<int>>& g) {
        int n = g.size(), ans1 = 0, ans2 = 0, ans3 = 0;
        for (int i = 0; i < n; i++) {
            int a = 0, b = 0;
            for (int j = 0; j < n; j++) {
                if (g[i][j] > 0) ans1++;
                a = max(a, g[i][j]);
                b = max(b, g[j][i]);
            }
            ans2 += a; ans3 += b;
        }
        return ans1 + ans2 + ans3;
    }
};
```
Python 代码：
```Python
class Solution:
    def projectionArea(self, g: List[List[int]]) -> int:
        n, ans1, ans2, ans3 = len(g), 0, 0, 0
        for i in range(n):
            a, b = 0, 0
            for j in range(n):
                if (g[i][j] > 0): 
                    ans1 += 1
                a, b = max(a, g[i][j]), max(b, g[j][i])
            ans2, ans3 = ans2 + a, ans3 + b
        return ans1 + ans2 + ans3
```
TypeScript 代码：
```TypeScript
function projectionArea(g: number[][]): number {
    let n = g.length, ans1 = 0, ans2 = 0, ans3 = 0;
    for (let i = 0; i < n; i++) {
        let a = 0, b = 0;
        for (let j = 0; j < n; j++) {
            if (g[i][j] > 0) ans1++;
            a = Math.max(a, g[i][j]);
            b = Math.max(b, g[j][i]);
        }
        ans2 += a; ans3 += b;
    }
    return ans1 + ans2 + ans3;
};
```
* 时间复杂度：$O(n^2)$
* 空间复杂度：$O(1)$

---

### 最后

这是我们「刷穿 LeetCode」系列文章的第 `No.883` 篇，系列开始于 2021/01/01，截止于起始日 LeetCode 上共有 1916 道题目，部分是有锁题，我们将先把所有不带锁的题目刷完。

在这个系列文章里面，除了讲解解题思路以外，还会尽可能给出最为简洁的代码。如果涉及通解还会相应的代码模板。

为了方便各位同学能够电脑上进行调试和提交代码，我建立了相关的仓库：https://github.com/SharingSource/LogicStack-LeetCode 。

在仓库地址里，你可以看到系列文章的题解链接、系列文章的相应代码、LeetCode 原题链接和其他优选题解。

