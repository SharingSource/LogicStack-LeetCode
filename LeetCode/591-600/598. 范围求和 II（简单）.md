### 题目描述

这是 LeetCode 上的 **[598. 范围求和 II](https://leetcode-cn.com/problems/range-addition-ii/solution/gong-shui-san-xie-jian-dan-mo-ni-ti-by-a-006h/)** ，难度为 **简单**。

Tag : 「模拟」



给定一个初始元素全部为 $0$，大小为 $m*n$ 的矩阵 $M$ 以及在 $M$ 上的一系列更新操作。

操作用二维数组表示，其中的每个操作用一个含有两个正整数 $a$ 和 $b$ 的数组表示，含义是将所有符合 $0 <= i < a$ 以及 $0 <= j < b$ 的元素 $M[i][j]$ 的值都增加 $14。

在执行给定的一系列操作后，你需要返回矩阵中含有最大整数的元素个数。

示例 1:
```
输入: 
m = 3, n = 3
operations = [[2,2],[3,3]]

输出: 4

解释: 
初始状态, M = 
[[0, 0, 0],
 [0, 0, 0],
 [0, 0, 0]]

执行完操作 [2,2] 后, M = 
[[1, 1, 0],
 [1, 1, 0],
 [0, 0, 0]]

执行完操作 [3,3] 后, M = 
[[2, 2, 1],
 [2, 2, 1],
 [1, 1, 1]]

M 中最大的整数是 2, 而且 M 中有4个值为2的元素。因此返回 4。
```
注意:
* $m$ 和 $n$ 的范围是 $[1,40000]$。
* $a$ 的范围是 $[1,m]$，$b$ 的范围是 $[1,n]$。
* 操作数目不超过 $10000$。

---

### 模拟

由于每次都是对 $0 \leq i < a$ 和 $0 \leq j < b$ 进行操作，因此每次操作都会包含点 $(0, 0)$，最后的最大值一定出现在位置 $(0, 0)$ 上。

问题转换为：什么范围内的数与位置 $(0, 0)$ 上的值相等，即什么范围会被每一次操作所覆盖。

不难发现，在所有的 $ops[i]$ 中的横纵坐标 $(x, y)$ 与左上角 $(0, 0)$ 形成的区域面积可确保被每次操作覆盖，$x * y$ 即是答案。

代码：
```Java
class Solution {
    public int maxCount(int m, int n, int[][] ops) {
        for (int[] op : ops) {
            m = Math.min(m, op[0]);
            n = Math.min(n, op[1]);
        }
        return m * n;
    }
}
```
* 时间复杂度：令 $k$ 为 $ops$ 数组的长度。复杂度为 $O(k)$
* 空间复杂度：$O(1)$

---

### 最后

这是我们「刷穿 LeetCode」系列文章的第 `No.598` 篇，系列开始于 2021/01/01，截止于起始日 LeetCode 上共有 1916 道题目，部分是有锁题，我们将先把所有不带锁的题目刷完。

在这个系列文章里面，除了讲解解题思路以外，还会尽可能给出最为简洁的代码。如果涉及通解还会相应的代码模板。

为了方便各位同学能够电脑上进行调试和提交代码，我建立了相关的仓库：https://github.com/SharingSource/LogicStack-LeetCode。

在仓库地址里，你可以看到系列文章的题解链接、系列文章的相应代码、LeetCode 原题链接和其他优选题解。

