### 题目描述

这是 LeetCode 上的 **[44. 通配符匹配](https://leetcode-cn.com/problems/wildcard-matching/solution/gong-shui-san-xie-xiang-jie-dong-tai-gui-ifyx/)** ，难度为 **困难**。

Tag : 「线性 DP」




给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 '?' 和 '*' 的通配符匹配。

* '?' 可以匹配任何单个字符。
* '*' 可以匹配任意字符串（包括空字符串）。
两个字符串完全匹配才算匹配成功。

说明:

* s 可能为空，且只包含从 a-z 的小写字母。
* p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。

示例 1:
```
输入:
s = "aa"
p = "a"
输出: false
解释: "a" 无法匹配 "aa" 整个字符串。
```
示例 2:
```
输入:
s = "aa"
p = "*"
输出: true
解释: '*' 可以匹配任意字符串。
```
示例 3:
```
输入:
s = "cb"
p = "?a"
输出: false
解释: '?' 可以匹配 'c', 但第二个 'a' 无法匹配 'b'。
```
示例 4:
```
输入:
s = "adceb"
p = "*a*b"
输出: true
解释: 
第一个 '*' 可以匹配空字符串, 
第二个 '*' 可以匹配字符串 "dce".
```
示例 5:
```
输入:
s = "acdcb"
p = "a*c?b"
输出: false
```



---

### 动态规划

这道题与 [10. 正则表达式匹配](https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&mid=2247484130&idx=1&sn=af3517194634dde1652ec72eb5ea9ff2&chksm=fd9ca9fdcaeb20eb1fd7509e3adf8fee6f75d77b8afbd30067ac11a56bd77b5066b0f164eb49&token=840813710&lang=zh_CN#rd) 的分析思路是类似的。

但和第 10 题相比，本题要简单一些。

整理一下题意，对于字符串 `p` 而言，有三种字符：

* 普通字符：需要和 `s` 中同一位置的字符完全匹配

* `'?'`：能够匹配 `s` 中同一位置的任意字符

* `'*'`：能够匹配任意字符串

所以本题关键是分析当出现 `'*'` 这种字符时，是匹配 0 个字符、还是 1 个字符、还是 2 个字符 ...

本题可以使用动态规划进行求解：

* 状态定义：`f(i,j)` 代表考虑 `s` 中以 `i` 为结尾的子串和 `p` 中的 `j` 为结尾的子串是否匹配。即最终我们要求的结果为 `f[n][m]` 。

* 状态转移：也就是我们要考虑 `f(i,j)` 如何求得，前面说到了 `p` 有三种字符，所以这里的状态转移也要分三种情况讨论：
  
  1. `p[j]` 为普通字符：匹配的条件是前面的字符匹配，同时 `s` 中的第 `i` 个字符和 `p` 中的第 `j` 位相同。 即 `f(i,j) = f(i - 1, j - 1) && s[i] == p[j]` 。
  2. `p[j]` 为 `'.'`：匹配的条件是前面的字符匹配，`s` 中的第 `i` 个字符可以是任意字符。即 `f(i,j) = f(i - 1, j - 1) && p[j] == '.'`。
  3. `p[j]` 为 `'*'`：可匹配任意长度的字符，可以匹配 0 个字符、匹配 1 个字符、匹配 2 个字符
  
      3.1. 当匹配为 0 个：`f(i,j) = f(i, j - 1)`
      
      3.2. 当匹配为 1 个：`f(i,j) = f(i - 1, j - 1)`
      
      3.3. 当匹配为 2 个：`f(i,j) = f(i - 2, j - 1)`
      
      ...
      
      3.k. 当匹配为 k 个：`f(i,j) = f(i - k, j - 1)`
      

因此对于 `p[j] = '*'` 的情况，想要 `f(i, j) = true`，只需要其中一种情况为 `true` 即可。也就是状态之间是「或」的关系：

$$f[i][j] = f[i][j - 1] || f[i - 1][j - 1] || ... || f[i - k][j - 1] (i >= k)$$
      
这意味着我们要对 `k` 种情况进行枚举检查吗？

其实并不用，对于这类问题，我们通常可以通过「代数」进简化，将 `i - 1` 代入上述的式子：

$$f[i - 1][j] = f[i - 1][j - 1] || f[i - 2][j - 1] || ... || f[i - k][j - 1] (i >= k)$$

可以发现，`f[i - 1][j]` 与 `f[i][j]` 中的 `f[i][j - 1]` 开始的后半部分是一样的，因此有：

$$f[i][j] = f[i][j - 1] || f[i - 1][j] (i >= 1)$$

*PS. 其实类似的推导，我在 [10. 正则表达式匹配](https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&mid=2247484130&idx=1&sn=af3517194634dde1652ec72eb5ea9ff2&chksm=fd9ca9fdcaeb20eb1fd7509e3adf8fee6f75d77b8afbd30067ac11a56bd77b5066b0f164eb49&token=840813710&lang=zh_CN#rd) 也做过，第 10 题的推导过程还涉及等差概念，我十分推荐你去回顾一下。如果你能搞懂第 10 题整个过程，这题其实就是小 Case。*

编码细节：

1. 通过上述的推导过程，你会发现设计不少的「回退检查」操作（即遍历到 `i` 位，要回头检查 `i - 1` 等），因此我们可以将「哨兵技巧」应用到本题，往两个字符串的头部插入哨兵
2. 对于 `p[j] = '.'` 和 `p[j] = 普通字符` 的情况，想要为 `true`，其实有共同的条件 `f[i - 1][j - 1] == true`，因此可以合到一起来做

代码：

```java
class Solution {
    public boolean isMatch(String ss, String pp) {
        int n = ss.length(), m = pp.length();
        // 技巧：往原字符头部插入空格，这样得到 char 数组是从 1 开始，而且可以使得 f[0][0] = true，可以将 true 这个结果滚动下去
        ss = " " + ss;
        pp = " " + pp;
        char[] s = ss.toCharArray();
        char[] p = pp.toCharArray();
        // f(i,j) 代表考虑 s 中的 1~i 字符和 p 中的 1~j 字符 是否匹配
        boolean[][] f = new boolean[n + 1][m + 1];
        f[0][0] = true;
        for (int i = 0; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                if (p[j] == '*') {
                    f[i][j] = f[i][j - 1] || (i - 1 >= 0 && f[i - 1][j]);
                } else {
                    f[i][j] = i - 1 >= 0 && f[i - 1][j - 1] && (s[i] == p[j] || p[j] == '?');
                }
            }
        }
        return f[n][m];
    }
}
```
* 时间复杂度：`n` 表示 `s` 的长度，`m` 表示 `p` 的长度，总共 `n * m` 个状态。复杂度为 $O(n * m)$
* 空间复杂度：使用了二维数组记录结果。复杂度为 $O(n * m)$

**再次强调，动态规划本质上是枚举（不重复的暴力枚举），因此其复杂度很好分析，有多少个状态就要被计算多少次，复杂度就为多少。**

---

### 最后

这是我们「刷穿 LeetCode」系列文章的第 `No.44` 篇，系列开始于 2021/01/01，截止于起始日 LeetCode 上共有 1916 道题目，部分是有锁题，我们将先把所有不带锁的题目刷完。

在这个系列文章里面，除了讲解解题思路以外，还会尽可能给出最为简洁的代码。如果涉及通解还会相应的代码模板。

为了方便各位同学能够电脑上进行调试和提交代码，我建立了相关的仓库：https://github.com/SharingSource/LogicStack-LeetCode 。

在仓库地址里，你可以看到系列文章的题解链接、系列文章的相应代码、LeetCode 原题链接和其他优选题解。

