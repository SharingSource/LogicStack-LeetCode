### é¢˜ç›®æè¿°

è¿™æ˜¯ LeetCode ä¸Šçš„ **[1334. é˜ˆå€¼è·ç¦»å†…é‚»å±…æœ€å°‘çš„åŸå¸‚](https://leetcode.cn/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/solutions/2526052/gong-shui-san-xie-han-gai-suo-you-cun-tu-svq7/)** ï¼Œéš¾åº¦ä¸º **ä¸­ç­‰**ã€‚

Tag : ã€Œæœ€çŸ­è·¯ã€ã€ã€Œå›¾ã€



æœ‰ $n$ ä¸ªåŸå¸‚ï¼ŒæŒ‰ä» $0$ åˆ° $n-1$ ç¼–å·ã€‚

ç»™ä½ ä¸€ä¸ªè¾¹æ•°ç»„ `edges`ï¼Œå…¶ä¸­ $edges[i] = [from_{i}, to_{i}, weight_{i}]$ ä»£è¡¨ $from_{i}$ å’Œ $to_{i}$ ä¸¤ä¸ªåŸå¸‚ä¹‹é—´çš„åŒå‘åŠ æƒè¾¹ï¼Œè·ç¦»é˜ˆå€¼æ˜¯ä¸€ä¸ªæ•´æ•° `distanceThreshold`ã€‚

è¿”å›èƒ½é€šè¿‡æŸäº›è·¯å¾„åˆ°è¾¾å…¶ä»–åŸå¸‚æ•°ç›®æœ€å°‘ã€ä¸”è·¯å¾„è·ç¦»æœ€å¤§ä¸º `distanceThreshold` çš„åŸå¸‚ã€‚å¦‚æœæœ‰å¤šä¸ªè¿™æ ·çš„åŸå¸‚ï¼Œåˆ™è¿”å›ç¼–å·æœ€å¤§çš„åŸå¸‚ã€‚

æ³¨æ„ï¼Œè¿æ¥åŸå¸‚ $i$ å’Œ $j$ çš„è·¯å¾„çš„è·ç¦»ç­‰äºæ²¿è¯¥è·¯å¾„çš„æ‰€æœ‰è¾¹çš„æƒé‡ä¹‹å’Œã€‚

ç¤ºä¾‹ 1ï¼š
![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/26/find_the_city_01.png)

```
è¾“å…¥ï¼šn = 4, edges = [[0,1,3],[1,2,1],[1,3,4],[2,3,1]], distanceThreshold = 4

è¾“å‡ºï¼š3

è§£é‡Šï¼šåŸå¸‚åˆ†å¸ƒå›¾å¦‚ä¸Šã€‚
æ¯ä¸ªåŸå¸‚é˜ˆå€¼è·ç¦» distanceThreshold = 4 å†…çš„é‚»å±…åŸå¸‚åˆ†åˆ«æ˜¯ï¼š
åŸå¸‚ 0 -> [åŸå¸‚ 1, åŸå¸‚ 2] 
åŸå¸‚ 1 -> [åŸå¸‚ 0, åŸå¸‚ 2, åŸå¸‚ 3] 
åŸå¸‚ 2 -> [åŸå¸‚ 0, åŸå¸‚ 1, åŸå¸‚ 3] 
åŸå¸‚ 3 -> [åŸå¸‚ 1, åŸå¸‚ 2] 
åŸå¸‚ 0 å’Œ 3 åœ¨é˜ˆå€¼è·ç¦» 4 ä»¥å†…éƒ½æœ‰ 2 ä¸ªé‚»å±…åŸå¸‚ï¼Œä½†æ˜¯æˆ‘ä»¬å¿…é¡»è¿”å›åŸå¸‚ 3ï¼Œå› ä¸ºå®ƒçš„ç¼–å·æœ€å¤§ã€‚
```
ç¤ºä¾‹ 2ï¼š
![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/26/find_the_city_02.png)

```
è¾“å…¥ï¼šn = 5, edges = [[0,1,2],[0,4,8],[1,2,3],[1,4,2],[2,3,1],[3,4,1]], distanceThreshold = 2

è¾“å‡ºï¼š0

è§£é‡Šï¼šåŸå¸‚åˆ†å¸ƒå›¾å¦‚ä¸Šã€‚ 
æ¯ä¸ªåŸå¸‚é˜ˆå€¼è·ç¦» distanceThreshold = 2 å†…çš„é‚»å±…åŸå¸‚åˆ†åˆ«æ˜¯ï¼š
åŸå¸‚ 0 -> [åŸå¸‚ 1] 
åŸå¸‚ 1 -> [åŸå¸‚ 0, åŸå¸‚ 4] 
åŸå¸‚ 2 -> [åŸå¸‚ 3, åŸå¸‚ 4] 
åŸå¸‚ 3 -> [åŸå¸‚ 2, åŸå¸‚ 4]
åŸå¸‚ 4 -> [åŸå¸‚ 1, åŸå¸‚ 2, åŸå¸‚ 3] 
åŸå¸‚ 0 åœ¨é˜ˆå€¼è·ç¦» 2 ä»¥å†…åªæœ‰ 1 ä¸ªé‚»å±…åŸå¸‚ã€‚
```

æç¤ºï¼š
* $2 <= n <= 100$
* $1 <= edges.length <= \frac{n \times (n - 1)}{2}$
* $edges[i].length = 3$
* $0 <= from_{i} < to_{i} < n$
* $1 <= weight_{i}, distanceThreshold <= 10^4$
* æ‰€æœ‰ $(from_{i}, to_{i})$ éƒ½æ˜¯ä¸åŒçš„ã€‚

---

### åŸºæœ¬åˆ†æ

è‹¥èƒ½é¢„å¤„ç†å›¾ä¸­ä»»æ„ä¸¤ç‚¹ $i$ å’Œ $j$ çš„æœ€çŸ­è·ç¦» `dist`ï¼Œé‚£ä¹ˆç»Ÿè®¡æ¯ä¸ªç‚¹ $i$ åœ¨å›¾ä¸­æœ‰å¤šå°‘æ»¡è¶³ $dist[j] \leq distanceThreshold$ çš„ç‚¹ $j$ å³ä¸ºç­”æ¡ˆã€‚

äºæ˜¯é—®é¢˜è½¬æ¢ä¸ºï¼š**å¦‚ä½•æ±‚è§£ç»™å®šå›¾ä¸­ï¼Œä»»æ„ä¸¤ç‚¹çš„æœ€çŸ­è·ç¦»**ã€‚

---

### å­˜å›¾

åœ¨å­¦ä¹ æœ€çŸ­è·¯ä¹‹å‰ï¼Œæˆ‘ä»¬å…ˆææ‡‚ä¼—å¤šå›¾è®ºé—®é¢˜çš„å‰ç½® ğŸ§€ ï¼šå­˜å›¾ã€‚

ä¸ºäº†æ–¹ä¾¿ï¼Œæˆ‘ä»¬çº¦å®š $n$ ä¸ºç‚¹æ•°ï¼Œ$m$ ä¸ºè¾¹æ•°ã€‚

æ ¹æ®ç‚¹å’Œè¾¹çš„æ•°é‡çº§å…³ç³»ï¼Œå¯ä»¥å°†å›¾åˆ†æˆå¦‚ä¸‹ä¸¤ç±»ï¼š

* ç¨ å¯†å›¾ï¼šè¾¹æ•°è¾ƒå¤šï¼Œè¾¹æ•°æ¥è¿‘äºç‚¹æ•°çš„å¹³æ–¹ï¼Œå³ $m \approx n^2$
* ç¨€ç–å›¾ï¼šè¾¹æ•°è¾ƒå°‘ï¼Œè¾¹æ•°æ¥è¿‘äºç‚¹æ•°ï¼Œå³ $m \approx n$

åŒæ—¶ï¼Œæ ¹æ®ã€Œç¨ å¯†å›¾ã€è¿˜æ˜¯ã€Œç¨€ç–å›¾ã€ï¼Œæˆ‘ä»¬æœ‰å¦‚ä¸‹å‡ ç§å­˜å›¾æ–¹å¼ï¼š

##### 1. é‚»æ¥çŸ©é˜µï¼ˆç¨ å¯†å›¾ï¼‰

è¿™æ˜¯ä¸€ç§ä½¿ç”¨äºŒç»´çŸ©é˜µæ¥è¿›è¡Œå­˜å›¾çš„æ–¹å¼ã€‚

```Java
// w[a][b] = c ä»£è¡¨ä» a åˆ° b æœ‰æƒé‡ä¸º c çš„è¾¹
int[][] g = new int[N][N];

// åŠ è¾¹æ“ä½œ
void add(int a, int b, int c) {
    g[a][b] = c;
}
```

##### 2. é‚»æ¥è¡¨ï¼ˆç¨€ç–å›¾ï¼‰

é‚»æ¥è¡¨åˆå«**é“¾å¼å‰å‘æ˜Ÿ**ï¼Œæ˜¯å¦ä¸€ç§å¸¸è§çš„å­˜å›¾æ–¹å¼ï¼Œå®ç°ä»£ç ä¸ã€Œä½¿ç”¨æ•°ç»„å­˜å‚¨å•é“¾è¡¨ã€ä¸€è‡´ï¼ˆå¤´æ’æ³•ï¼‰ã€‚

```Java
int[] he = new int[N], e = new int[M], ne = new int[M], w = new int[M];

// åŠ è¾¹æ“ä½œ
void add(int a, int b, int c) {
    e[idx] = b;
    ne[idx] = he[a];
    w[idx] = c;
    he[a] = idx++;
}
```

é¦–å…ˆ `idx` æ˜¯ç”¨æ¥å¯¹è¾¹è¿›è¡Œç¼–å·çš„ï¼Œç„¶åå¯¹å­˜å›¾ç”¨åˆ°çš„å‡ ä¸ªæ•°ç»„ä½œç®€å•è§£é‡Šï¼š
* `he` æ•°ç»„ï¼šå­˜å‚¨æ˜¯æŸä¸ªèŠ‚ç‚¹æ‰€å¯¹åº”çš„è¾¹çš„é›†åˆï¼ˆé“¾è¡¨ï¼‰çš„å¤´ç»“ç‚¹ï¼›
* `e`  æ•°ç»„ï¼šç”±äºè®¿é—®æŸä¸€æ¡è¾¹æŒ‡å‘çš„èŠ‚ç‚¹ï¼›
* `ne` æ•°ç»„ï¼šç”±äºæ˜¯ä»¥é“¾è¡¨çš„å½¢å¼è¿›è¡Œå­˜è¾¹ï¼Œè¯¥æ•°ç»„å°±æ˜¯ç”¨äºæ‰¾åˆ°ä¸‹ä¸€æ¡è¾¹ï¼›
* `w`  æ•°ç»„ï¼šç”¨äºè®°å½•æŸæ¡è¾¹çš„æƒé‡ä¸ºå¤šå°‘ã€‚

å½“æˆ‘ä»¬æƒ³è¦éå†æ‰€æœ‰ç”± `a` ç‚¹å‘å‡ºçš„è¾¹æ—¶ï¼Œå¯ä»¥ä½¿ç”¨å¦‚ä¸‹æ–¹å¼ï¼š

```Java
for (int i = he[a]; i != -1; i = ne[i]) {
    int b = e[i], c = w[i]; // å­˜åœ¨ç”± a æŒ‡å‘ b çš„è¾¹ï¼Œæƒé‡ä¸º c
}
```

##### 3. ç±»

è¿™æ˜¯æœ€ç®€å•ï¼Œä½†ä½¿ç”¨é¢‘ç‡æœ€ä½çš„å­˜å›¾æ–¹å¼ã€‚

åªæœ‰å½“æˆ‘ä»¬éœ€è¦ç¡®ä¿æŸä¸ªæ“ä½œå¤æ‚åº¦ä¸ºä¸¥æ ¼ $O(m)$ æ—¶ï¼Œæ‰ä¼šè€ƒè™‘ä½¿ç”¨ã€‚

å…·ä½“çš„ï¼Œå»ºç«‹ä¸€ä¸ªç±»æ¥è®°å½•æœ‰å‘è¾¹ä¿¡æ¯ï¼š

```Java
class Edge {
    // ä»£è¡¨ä» a åˆ° b æœ‰ä¸€æ¡æƒé‡ä¸º c çš„è¾¹
    int a, b, c;
    Edge(int _a, int _b, int _c) {
        a = _a; b = _b; c = _c;
    }
}
```

éšåï¼Œä½¿ç”¨è¯¸å¦‚ `List` çš„å®¹å™¨ï¼Œå­˜èµ·æ‰€æœ‰è¾¹å¯¹è±¡ã€‚åœ¨éœ€è¦éå†æ‰€æœ‰è¾¹æ—¶ï¼Œå¯¹å®¹å™¨è¿›è¡Œè¿›è¡Œéå†ï¼š

```Java
List<Edge> es = new ArrayList<>();

...

for (Edge e : es) {
    ...
}
```

ç»¼ä¸Šï¼Œç¬¬  $3$ ç§æ–¹å¼ï¼Œå¾€å¾€æ˜¯ `OJ` ç»™æˆ‘ä»¬è¾¹ä¿¡æ¯çš„æ–¹å¼ï¼Œæˆ‘ä»¬è‡ªå·±å‡ ä¹ä¸ä¼šç”¨è¿™ç§æ–¹å¼å»ºå›¾ã€‚

å®é™…è¿ç”¨ä¸­ï¼Œç†Ÿç»ƒæŒæ¡ã€Œå¦‚ä½•æ ¹æ®ç‚¹å’Œè¾¹çš„æ•°é‡çº§å…³ç³»ï¼Œæ¥å†³å®šä½¿ç”¨é‚»æ¥çŸ©é˜µï¼ˆç¨ å¯†å›¾ï¼‰è¿˜æ˜¯é‚»æ¥è¡¨ï¼ˆç¨€ç–å›¾ï¼‰ã€å³å¯ã€‚

---

### Floydï¼ˆé‚»æ¥çŸ©é˜µï¼‰

`Floyd` ç®—æ³•ä½œä¸ºã€Œå¤šæºæ±‡æœ€çŸ­è·¯ã€ç®—æ³•ï¼Œå¯¹äºæœ¬é¢˜å°¤å…¶é€‚åˆã€‚

`Floyd` ç®—æ³•åŸºäºã€ŒåŠ¨æ€è§„åˆ’ã€ï¼Œå…¶åŸå§‹ä¸‰ç»´çŠ¶æ€å®šä¹‰ä¸º $dist[p][i][j]$ï¼Œè¡¨ç¤ºã€Œæ‰€æœ‰ä»ç‚¹ $i$ åˆ°ç‚¹ $j$ï¼Œä¸”å…è®¸ç»è¿‡ç‚¹é›† $(1, ... , p)$ çš„è·¯å¾„ã€ä¸­çš„æœ€çŸ­è·ç¦»ã€‚

çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼š
$$
dist[p][i][j] = \min(dist[p - 1][i][j], dist[p - 1][i][p] + dist[p - 1][p][j])
$$
$dist[p - 1][i][j]$ ä»£è¡¨ä» $i$ åˆ° $j$ ä½†å¿…ç„¶ä¸ç»è¿‡ç‚¹ $p$ çš„è·¯å¾„ï¼Œ$dist[p - 1][i][p] + dist[p - 1][p][j]$ ä»£è¡¨å¿…ç„¶ç»è¿‡ç‚¹ $p$ çš„è·¯å¾„ï¼Œä¸¤è€…ä¸­å–è¾ƒå°å€¼æ›´æ–° $dist[p][i][j]$ã€‚

ä¸éš¾å‘ç°ä»»æ„çš„ $dist[p][X][Y]$ ä¾èµ–äº $dist[p - 1][X][Y]$ï¼Œå¯é‡‡ç”¨ã€Œæ»šåŠ¨æ•°ç»„ã€çš„æ–¹å¼è¿›è¡Œä¼˜åŒ–ã€‚

å°† `dist` å£°æ˜ä¸ºäºŒç»´æ•°ç»„ï¼Œ$dist[i][j]$ ä»£è¡¨ä»ç‚¹ $i$ åˆ°ç‚¹ $j$ çš„æœ€çŸ­è·ç¦»ï¼Œå¹¶é‡‡å– [æšä¸¾ä¸­è½¬ç‚¹ - æšä¸¾èµ·ç‚¹ - æšä¸¾ç»ˆç‚¹] ä¸‰å±‚å¾ªç¯çš„æ–¹å¼æ›´æ–° $dist[i][j]$ã€‚

å¦‚æ­¤ä¸€æ¥ï¼Œè·‘ä¸€é `Floyd` ç®—æ³•ä¾¿å¯å¾—å‡ºä»»æ„ä¸¤ç‚¹çš„æœ€çŸ­è·ç¦»ã€‚

é€šè¿‡ä¸Šè¿°æ¨å¯¼ï¼Œä¸éš¾å‘ç°ï¼Œæˆ‘ä»¬å¹¶æ²¡æåŠè¾¹æƒçš„æ­£è´Ÿé—®é¢˜ï¼Œå› æ­¤ `Floyd` ç®—æ³•å¯¹è¾¹æƒçš„æ­£è´Ÿæ²¡æœ‰é™åˆ¶è¦æ±‚ï¼ˆå¯å¤„ç†æ­£è´Ÿæƒè¾¹çš„å›¾ï¼‰ï¼Œä¸”èƒ½åˆ©ç”¨ `Floyd` ç®—æ³•å¯èƒ½å¤Ÿå¯¹å›¾ä¸­è´Ÿç¯è¿›è¡Œåˆ¤å®šã€‚

Java ä»£ç ï¼š

```Java
class Solution {
    public int findTheCity(int n, int[][] edges, int distanceThreshold) {
        int[][] g = new int[n][n];
        // åˆå§‹åŒ–é‚»æ¥çŸ©é˜µ
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                g[i][j] = i == j ? 0 : 0x3f3f3f3f;
            }
        }
        // å­˜å›¾
        for (int[] e : edges) {
            int a = e[0], b = e[1], c = e[2];
            g[a][b] = g[b][a] = Math.min(g[a][b], c);
        }
        // æœ€çŸ­è·¯
        floyd(g);
        // ç»Ÿè®¡ç­”æ¡ˆ
        int ans = -1, cnt = n + 10;
        for (int i = 0; i < n; i++) {
            int cur = 0;
            for (int j = 0; j < n; j++) {
                if (i != j && g[i][j] <= distanceThreshold) cur++;
            }
            if (cur <= cnt) {
                cnt = cur; ans = i;
            }
        }
        return ans;
    }
    void floyd(int[][] g) {
        int n = g.length;
        // floyd åŸºæœ¬æµç¨‹ä¸ºä¸‰å±‚å¾ªç¯: [æšä¸¾ä¸­è½¬ç‚¹ - æšä¸¾èµ·ç‚¹ - æšä¸¾ç»ˆç‚¹] => æ¾å¼›æ“ä½œ  
        for (int p = 0; p < n; p++) {
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    g[i][j] = Math.min(g[i][j], g[i][p] + g[p][j]);
                }
            }
        }
    }
}
```
C++ ä»£ç ï¼š
```C++
class Solution {
public:
    int findTheCity(int n, vector<vector<int>>& edges, int distanceThreshold) {
        vector<vector<int>> g(n, vector<int>(n, 0x3f3f3f3f));
        // åˆå§‹åŒ–é‚»æ¥çŸ©é˜µ
        for (int i = 0; i < n; i++) g[i][i] = 0;
        // å­˜å›¾
        for (const auto& e : edges) {
            int a = e[0], b = e[1], c = e[2];
            g[a][b] = g[b][a] = min(g[a][b], c);
        }
        // æœ€çŸ­è·¯
        floyd(g);
        // ç»Ÿè®¡ç­”æ¡ˆ
        int ans = -1, cnt = n + 10;
        for (int i = 0; i < n; i++) {
            int cur = 0;
            for (int j = 0; j < n; j++) {
                if (i != j && g[i][j] <= distanceThreshold) cur++;
            }
            if (cur <= cnt) {
                cnt = cur; ans = i;
            }
        }
        return ans;
    }
    void floyd(vector<vector<int>>& g) {
        int n = g.size();
        // floyd åŸºæœ¬æµç¨‹ä¸ºä¸‰å±‚å¾ªç¯: [æšä¸¾ä¸­è½¬ç‚¹ - æšä¸¾èµ·ç‚¹ - æšä¸¾ç»ˆç‚¹] => æ¾å¼›æ“ä½œ  
        for (int p = 0; p < n; p++) {
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    g[i][j] = min(g[i][j], g[i][p] + g[p][j]);
                }
            }
        }
    }
};

```
Python ä»£ç ï¼š
```Python
class Solution:
    def findTheCity(self, n: int, edges: List[List[int]], distanceThreshold: int) -> int:
        def floyd(g: List[List[int]]) -> None:
            n = len(g)
            # floyd åŸºæœ¬æµç¨‹ä¸ºä¸‰å±‚å¾ªç¯: [æšä¸¾ä¸­è½¬ç‚¹ - æšä¸¾èµ·ç‚¹ - æšä¸¾ç»ˆç‚¹] => æ¾å¼›æ“ä½œ
            for p in range(n):
                for i in range(n):
                    for j in range(n):
                        g[i][j] = min(g[i][j], g[i][p] + g[p][j])

        g = [[float('inf')] * n for _ in range(n)]
        # åˆå§‹åŒ–é‚»æ¥çŸ©é˜µ
        for i in range(n):
            g[i][i] = 0
        # å­˜å›¾
        for a, b, c in edges:
            g[a][b] = g[b][a] = min(g[a][b], c)
        # æœ€çŸ­è·¯
        floyd(g)
        # ç»Ÿè®¡ç­”æ¡ˆ
        ans, cnt = -1, n + 10
        for i in range(n):
            cur = sum(1 for j in range(n) if i != j and g[i][j] <= distanceThreshold)
            if cur <= cnt:
                cnt, ans = cur, i
        return ans
```
TypeScript ä»£ç ï¼š
```TypeScript
function findTheCity(n: number, edges: number[][], distanceThreshold: number): number {
    const floyd = function (g: number[][]): void {
        const n = g.length;
        // floyd åŸºæœ¬æµç¨‹ä¸ºä¸‰å±‚å¾ªç¯: [æšä¸¾ä¸­è½¬ç‚¹ - æšä¸¾èµ·ç‚¹ - æšä¸¾ç»ˆç‚¹] => æ¾å¼›æ“ä½œ
        for (let p = 0; p < n; p++) {
            for (let i = 0; i < n; i++) {
                for (let j = 0; j < n; j++) {
                    g[i][j] = Math.min(g[i][j], g[i][p] + g[p][j]);
                }
            }
        }
    }

    const g = Array.from({ length: n }, () => Array(n).fill(0x3f3f3f3f));
    // åˆå§‹åŒ–é‚»æ¥çŸ©é˜µ
    for (let i = 0; i < n; i++) g[i][i] = 0;
    // å­˜å›¾
    for (const [a, b, c] of edges) g[a][b] = g[b][a] = Math.min(g[a][b], c);
    // æœ€çŸ­è·¯
    floyd(g);
    // ç»Ÿè®¡ç­”æ¡ˆ
    let ans = -1, cnt = n + 10;
    for (let i = 0; i < n; i++) {
        let cur = 0;
        for (let j = 0; j < n; j++) {
            if (i !== j && g[i][j] <= distanceThreshold) cur++;
        }
        if (cur <= cnt) {
            cnt = cur; ans = i;
        }
    }
    return ans;
};
```
* æ—¶é—´å¤æ‚åº¦ï¼šåˆå§‹åŒ–é‚»æ¥çŸ©é˜µå’Œå»ºå›¾å¤æ‚åº¦ä¸º $O(n^2 + m)$ï¼›`floyd` ç®—æ³•å¤æ‚åº¦ä¸º $O(n^3)$ï¼›ç»Ÿè®¡ç­”æ¡ˆå¤æ‚åº¦ä¸º $O(n^2)$ï¼›æ•´ä½“å¤æ‚åº¦ä¸º $O(n^3 + m)$
* ç©ºé—´å¤æ‚åº¦ï¼š$O(n^2)$

---

### æœ´ç´  Dijkstraï¼ˆé‚»æ¥çŸ©é˜µï¼‰

æœ€ä¸ºç»å…¸çš„ã€Œå•æºæœ€çŸ­è·¯ã€ç®—æ³•ï¼Œé€šå¸¸æ­é…ã€Œé‚»æ¥çŸ©é˜µã€ä½¿ç”¨ï¼Œåº”ç”¨åœ¨è¾¹æ•°è¾ƒå¤šçš„â€œç¨ å¯†å›¾â€ä¸Šã€‚

æœ´ç´  `Dijkstra` ç®—æ³•åŸºäºã€Œè´ªå¿ƒã€ï¼Œé€šè¿‡ç»´æŠ¤ä¸€ç»´çš„è·ç¦»æ•°ç»„ `dist` å®ç°ï¼Œ$dist[i]$ è¡¨ç¤ºä»æºç‚¹å‡ºå‘åˆ°ç‚¹ $i$ çš„æœ€çŸ­è·ç¦»ã€‚

æœ´ç´  `Dijkstra` ç®—æ³•åœ¨æ¯ä¸€æ¬¡è¿­ä»£ä¸­ï¼Œéƒ½é€‰æ‹© `dist` ä¸­å€¼æœ€å°çš„ç‚¹è¿›è¡Œæ¾å¼›æ“ä½œï¼Œé€æ¸æ‰©å±•æœ€çŸ­è·¯å¾„èŒƒå›´ã€‚

Java ä»£ç ï¼š

```Java
class Solution {
    public int findTheCity(int n, int[][] edges, int distanceThreshold) {
        int[][] g = new int[n][n];
        // åˆå§‹åŒ–é‚»æ¥çŸ©é˜µ
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                g[i][j] = i == j ? 0 : 0x3f3f3f3f;
            }
        }
        // å­˜å›¾
        for (int[] e : edges) {
            int a = e[0], b = e[1], c = e[2];
            g[a][b] = g[b][a] = Math.min(g[a][b], c);
        }
        int ans = -1, cnt = n + 10;
        for (int i = 0; i < n; i++) {
            // å•æºæœ€çŸ­è·¯
            int[] dist = dijkstra(g, i);
            int cur = 0;
            for (int j = 0; j < n; j++) {
                if (i != j && dist[j] <= distanceThreshold) cur++;
            }
            if (cur <= cnt) {
                cnt = cur; ans = i;
            }
        }
        return ans;
    }
    int[] dijkstra(int[][] g, int x) {
        int n = g.length;
        // èµ·å§‹å…ˆå°†æ‰€æœ‰çš„ç‚¹æ ‡è®°ä¸ºã€Œæœªæ›´æ–°ã€å’Œã€Œè·ç¦»ä¸ºæ­£æ— ç©·ã€
        boolean[] vis = new boolean[n];
        int[] dist = new int[n];
        Arrays.fill(dist, 0x3f3f3f3f);
        // åªæœ‰èµ·ç‚¹æœ€çŸ­è·ç¦»ä¸º 0
        dist[x] = 0;
        // æœ‰å¤šå°‘ä¸ªç‚¹å°±è¿­ä»£å¤šå°‘æ¬¡
        for (int k = 0; k < n; k++) {
            // æ¯æ¬¡æ‰¾åˆ°ã€Œæœ€çŸ­è·ç¦»æœ€å°ã€ä¸”ã€Œæœªè¢«æ›´æ–°ã€çš„ç‚¹ t
            int t = -1;
            for (int i = 0; i < n; i++) {
                if (!vis[i] && (t == -1 || dist[i] < dist[t])) t = i;
            }
            // æ ‡è®°ç‚¹ t ä¸ºå·²æ›´æ–°
            vis[t] = true;
            // ç”¨ç‚¹ t çš„ã€Œæœ€å°è·ç¦»ã€æ›´æ–°å…¶ä»–ç‚¹
            for (int i = 0; i < n; i++) dist[i] = Math.min(dist[i], dist[t] + g[t][i]);
        }
        return dist;
    }
}
```
C++ ä»£ç ï¼š
```C++
class Solution {
public:
    int findTheCity(int n, vector<vector<int>>& edges, int distanceThreshold) {
        vector<vector<int>> g(n, vector<int>(n, 0x3f3f3f3f));
        // åˆå§‹åŒ–é‚»æ¥çŸ©é˜µ
        for (int i = 0; i < n; i++) g[i][i] = 0;
        // å­˜å›¾
        for (const auto& e : edges) {
            int a = e[0], b = e[1], c = e[2];
            g[a][b] = g[b][a] = min(g[a][b], c);
        }
        int ans = -1, cnt = n + 10;
        for (int i = 0; i < n; i++) {
            // å•æºæœ€çŸ­è·¯
            vector<int> dist = dijkstra(g, i);
            int cur = count_if(dist.begin(), dist.end(), [distanceThreshold](int d) { return d <= distanceThreshold; });
            if (cur <= cnt) {
                cnt = cur; ans = i;
            }
        }
        return ans;
    }
    vector<int> dijkstra(const vector<vector<int>>& g, int x) {
        int n = g.size();
        vector<bool> vis(n, false);
        vector<int> dist(n, 0x3f3f3f3f);
        // åªæœ‰èµ·ç‚¹æœ€çŸ­è·ç¦»ä¸º 0
        dist[x] = 0;
        // æœ‰å¤šå°‘ä¸ªç‚¹å°±è¿­ä»£å¤šå°‘æ¬¡
        for (int k = 0; k < n; k++) {
            // æ¯æ¬¡æ‰¾åˆ°ã€Œæœ€çŸ­è·ç¦»æœ€å°ã€ä¸”ã€Œæœªè¢«æ›´æ–°ã€çš„ç‚¹ t
            int t = -1;
            for (int i = 0; i < n; i++) {
                if (!vis[i] && (t == -1 || dist[i] < dist[t])) t = i;
            }
            // æ ‡è®°ç‚¹ t ä¸ºå·²æ›´æ–°
            vis[t] = true;
            // ç”¨ç‚¹ t çš„ã€Œæœ€å°è·ç¦»ã€æ›´æ–°å…¶ä»–ç‚¹
            for (int i = 0; i < n; i++) dist[i] = min(dist[i], dist[t] + g[t][i]);
        }
        return dist;
    }
};
```
Python ä»£ç ï¼š
```Python
class Solution:
    def findTheCity(self, n: int, edges: List[List[int]], distanceThreshold: int) -> int:
        def dijkstra(g, x):
            n = len(g)
            vis = [False] * n
            dist = [float('inf')] * n
            # åªæœ‰èµ·ç‚¹æœ€çŸ­è·ç¦»ä¸º 0
            dist[x] = 0
            # æœ‰å¤šå°‘ä¸ªç‚¹å°±è¿­ä»£å¤šå°‘æ¬¡
            for k in range(n):
                # æ¯æ¬¡æ‰¾åˆ°ã€Œæœ€çŸ­è·ç¦»æœ€å°ã€ä¸”ã€Œæœªè¢«æ›´æ–°ã€çš„ç‚¹ t
                t = min((i for i in range(n) if not vis[i]), key=lambda i: dist[i])
                # æ ‡è®°ç‚¹ t ä¸ºå·²æ›´æ–°
                vis[t] = True
                # ç”¨ç‚¹ t çš„ã€Œæœ€å°è·ç¦»ã€æ›´æ–°å…¶ä»–ç‚¹
                for i in range(n):
                    dist[i] = min(dist[i], dist[t] + g[t][i])
            return dist

        g = [[float('inf')] * n for _ in range(n)]
        # åˆå§‹åŒ–é‚»æ¥çŸ©é˜µ
        for i in range(n):
            g[i][i] = 0
        # å­˜å›¾
        for a, b, c in edges:
            g[a][b] = g[b][a] = min(g[a][b], c)
        ans, cnt = -1, n + 10
        for i in range(n):
            # å•æºæœ€çŸ­è·¯
            dist = dijkstra(g, i)
            cur = sum(1 for j in range(n) if i != j and dist[j] <= distanceThreshold)
            if cur <= cnt:
                cnt, ans = cur, i
        return ans
```
TypeScript ä»£ç ï¼š
```TypeScript
function findTheCity(n: number, edges: number[][], distanceThreshold: number): number {
    const dijkstra = function (g: number[][], x: number): number[]  {
        const n = g.length;
        const vis = Array(n).fill(false), dist = Array(n).fill(0x3f3f3f3f);
        // åªæœ‰èµ·ç‚¹æœ€çŸ­è·ç¦»ä¸º 0
        dist[x] = 0;
        // æœ‰å¤šå°‘ä¸ªç‚¹å°±è¿­ä»£å¤šå°‘æ¬¡
        for (let k = 0; k < n; k++) {
            // æ¯æ¬¡æ‰¾åˆ°ã€Œæœ€çŸ­è·ç¦»æœ€å°ã€ä¸”ã€Œæœªè¢«æ›´æ–°ã€çš„ç‚¹ t
            let t = -1;
            for (let i = 0; i < n; i++) {
                if (!vis[i] && (t === -1 || dist[i] < dist[t])) t = i;
            }
            // æ ‡è®°ç‚¹ t ä¸ºå·²æ›´æ–°
            vis[t] = true;
            // ç”¨ç‚¹ t çš„ã€Œæœ€å°è·ç¦»ã€æ›´æ–°å…¶ä»–ç‚¹
            for (let i = 0; i < n; i++) dist[i] = Math.min(dist[i], dist[t] + g[t][i]);
        }
        return dist;
    }
    
    const g = Array.from({ length: n }, () => Array(n).fill(0x3f3f3f3f));
    // åˆå§‹åŒ–é‚»æ¥çŸ©é˜µ
    for (let i = 0; i < n; i++) g[i][i] = 0;
    // å­˜å›¾
    for (const [a, b, c] of edges) g[a][b] = g[b][a] = Math.min(g[a][b], c);
    let ans = -1, cnt = n + 10;
    for (let i = 0; i < n; i++) {
        // å•æºæœ€çŸ­è·¯
        const dist = dijkstra(g, i);
        const cur = dist.filter(d => d <= distanceThreshold).length;
        if (cur <= cnt) {
            cnt = cur; ans = i;
        }
    }
    return ans;
};
```
* æ—¶é—´å¤æ‚åº¦ï¼šåˆå§‹åŒ–é‚»æ¥çŸ©é˜µå’Œå»ºå›¾å¤æ‚åº¦ä¸º $O(n^2 + m)$ï¼›ç»Ÿè®¡ç­”æ¡ˆæ—¶ï¼Œå…±æ‰§è¡Œ $n$ æ¬¡æœ´ç´  `dijkstra` ç®—æ³•ï¼Œæœ´ç´  `dijkstra` å¤æ‚åº¦ä¸º $O(n^2)$ï¼Œæ€»å¤æ‚åº¦ä¸º $O(n^3)$ã€‚æ•´ä½“å¤æ‚åº¦ä¸º $O(n^3 + m)$
* ç©ºé—´å¤æ‚åº¦ï¼š$O(n^2)$

---

### å †ä¼˜åŒ– Dijkstraï¼ˆé‚»æ¥è¡¨ï¼‰

å †ä¼˜åŒ– `Dijkstra` ç®—æ³•ä¸æœ´ç´  `Dijkstra` ç®—æ³•éƒ½æ˜¯ã€Œå•æºæœ€çŸ­è·¯ã€ç®—æ³•ã€‚

å †ä¼˜åŒ– `Dijkstra` ç®—æ³•é€šè¿‡æ•°æ®ç»“æ„ã€Œä¼˜å…ˆé˜Ÿåˆ—ï¼ˆå †ï¼‰ã€æ¥ä¼˜åŒ–æœ´ç´  `Dijkstra` ä¸­çš„â€œæ‰¾ `dist` ä¸­å€¼æœ€å°çš„ç‚¹â€çš„è¿‡ç¨‹ã€‚

ç›¸æ¯”äºå¤æ‚åº¦ä¸è¾¹æ•°æ— å…³çš„ $O(n^2)$ æœ´ç´  `Dijkstra` ç®—æ³•ï¼Œå¤æ‚åº¦ä¸è¾¹æ•°ç›¸å…³çš„ $O(m\log{n})$ å †ä¼˜åŒ– `Dijkstra` ç®—æ³•æ›´é€‚åˆè¾¹è¾ƒå°‘çš„â€œç¨€ç–å›¾â€ã€‚

Java ä»£ç ï¼š

```Java
class Solution {
    int N = 110, M = N * N, INF = 0x3f3f3f3f, idx, n;
    int[] he = new int[N], e = new int[M], ne = new int[M], w = new int[M];
    void add(int a, int b, int c) {
        e[idx] = b;
        ne[idx] = he[a];
        w[idx] = c;
        he[a] = idx++;
    }
    public int findTheCity(int _n, int[][] edges, int distanceThreshold) {
        n = _n;
        // åˆå§‹åŒ–é“¾è¡¨å¤´
        Arrays.fill(he, -1);
        // å­˜å›¾
        for (int[] e : edges) {
            int a = e[0], b = e[1], c = e[2];
            add(a, b, c); add(b, a, c);
        }
        // ç»Ÿè®¡ç­”æ¡ˆ
        int ans = -1, cnt = n + 10;
        for (int i = 0; i < n; i++) {
            // å•æºæœ€çŸ­è·¯
            int[] dist = dijkstra(i);
            int cur = 0;
            for (int j = 0; j < n; j++) {
                if (i != j && dist[j] <= distanceThreshold) cur++;
            }
            if (cur <= cnt) {
                cnt = cur; ans = i;
            }
        }
        return ans;
    }
    int[] dijkstra(int x) {
        // èµ·å§‹å…ˆå°†æ‰€æœ‰çš„ç‚¹æ ‡è®°ä¸ºã€Œæœªæ›´æ–°ã€å’Œã€Œè·ç¦»ä¸ºæ­£æ— ç©·ã€
        int[] dist = new int[n];
        Arrays.fill(dist, 0x3f3f3f3f);
        boolean[] vis = new boolean[n];
        dist[x] = 0;
        // ä½¿ç”¨ã€Œä¼˜å…ˆé˜Ÿåˆ—ã€å­˜å‚¨æ‰€æœ‰å¯ç”¨äºæ›´æ–°çš„ç‚¹
        // ä»¥ (ç‚¹ç¼–å·, åˆ°èµ·ç‚¹çš„è·ç¦») è¿›è¡Œå­˜å‚¨ï¼Œä¼˜å…ˆå¼¹å‡ºã€Œæœ€çŸ­è·ç¦»ã€è¾ƒå°çš„ç‚¹
        PriorityQueue<int[]> q = new PriorityQueue<>((a,b)->a[1]-b[1]);
        q.add(new int[]{x, 0});
        while (!q.isEmpty()) {
            // æ¯æ¬¡ä»ã€Œä¼˜å…ˆé˜Ÿåˆ—ã€ä¸­å¼¹å‡º
            int[] poll = q.poll();
            int u = poll[0], step = poll[1];
            // å¦‚æœå¼¹å‡ºçš„ç‚¹è¢«æ ‡è®°ã€Œå·²æ›´æ–°ã€ï¼Œåˆ™è·³è¿‡
            if (vis[u]) continue;
            // æ ‡è®°è¯¥ç‚¹ã€Œå·²æ›´æ–°ã€ï¼Œå¹¶ä½¿ç”¨è¯¥ç‚¹æ›´æ–°å…¶ä»–ç‚¹çš„ã€Œæœ€çŸ­è·ç¦»ã€
            vis[u] = true;
            for (int i = he[u]; i != -1; i = ne[i]) {
                int j = e[i];
                if (dist[j] <= dist[u] + w[i]) continue;
                dist[j] = dist[u] + w[i];
                q.add(new int[]{j, dist[j]});
            }
        }
        return dist;
    }
}
```
C++ ä»£ç ï¼š
```C++
class Solution {
public:
    static const int N = 110, M = N * N;
    int he[N], e[M], ne[M], w[M], idx, n, INF = 0x3f3f3f3f;
    void add(int a, int b, int c) {
        e[idx] = b;
        ne[idx] = he[a];
        w[idx] = c;
        he[a] = idx++;
    }
    int findTheCity(int _n, vector<vector<int>>& edges, int distanceThreshold) {
        n = _n;
        // åˆå§‹åŒ–é“¾è¡¨å¤´
        fill(he, he + n, -1);
        // å­˜å›¾
        for (const auto& e : edges) {
            int a = e[0], b = e[1], c = e[2];
            add(a, b, c); add(b, a, c);
        }
        // ç»Ÿè®¡ç­”æ¡ˆ
        int ans = -1, cnt = n + 10;
        for (int i = 0; i < n; i++) {
            // å•æºæœ€çŸ­è·¯
            vector<int> dist = dijkstra(i);
            int cur = count_if(dist.begin(), dist.end(), [distanceThreshold](int d) { return d <= distanceThreshold; });
            if (cur <= cnt) {
                cnt = cur; ans = i;
            }
        }
        return ans;
    }
    vector<int> dijkstra(int x) {
        // èµ·å§‹å…ˆå°†æ‰€æœ‰çš„ç‚¹æ ‡è®°ä¸ºã€Œæœªæ›´æ–°ã€å’Œã€Œè·ç¦»ä¸ºæ­£æ— ç©·ã€
        vector<int> dist(n, INF);
        vector<bool> vis(n, false);
        dist[x] = 0;
        // ä½¿ç”¨ã€Œä¼˜å…ˆé˜Ÿåˆ—ã€å­˜å‚¨æ‰€æœ‰å¯ç”¨äºæ›´æ–°çš„ç‚¹
        // ä»¥ (åˆ°èµ·ç‚¹çš„è·ç¦», ç‚¹ç¼–å·) è¿›è¡Œå­˜å‚¨ï¼Œä¼˜å…ˆå¼¹å‡ºã€Œæœ€çŸ­è·ç¦»ã€è¾ƒå°çš„ç‚¹
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> q;
        q.push({0, x});
        while (!q.empty()) {
            // æ¯æ¬¡ä»ã€Œä¼˜å…ˆé˜Ÿåˆ—ã€ä¸­å¼¹å‡º
            auto [step, u] = q.top();
            q.pop();
            // å¦‚æœå¼¹å‡ºçš„ç‚¹è¢«æ ‡è®°ã€Œå·²æ›´æ–°ã€ï¼Œåˆ™è·³è¿‡
            if (vis[u]) continue;
            // æ ‡è®°è¯¥ç‚¹ã€Œå·²æ›´æ–°ã€ï¼Œå¹¶ä½¿ç”¨è¯¥ç‚¹æ›´æ–°å…¶ä»–ç‚¹çš„ã€Œæœ€çŸ­è·ç¦»ã€
            vis[u] = true;
            for (int i = he[u]; i != -1; i = ne[i]) {
                int j = e[i];
                if (dist[j] <= dist[u] + w[i]) continue;
                dist[j] = dist[u] + w[i];
                q.push({dist[j], j});
            }
        }
        return dist;
    }
};
```
Python ä»£ç ï¼š
```Python
import heapq

class Solution:
    def findTheCity(self, n: int, edges: List[List[int]], distanceThreshold: int) -> int:
        N, M, INF, idx = 110, 110 * 110, float('inf'), 0
        he, e, ne, w = [-1] * N, [0] * M, [0] * M, [0] * M

        def add(a, b, c):
            nonlocal idx
            e[idx] = b
            ne[idx] = he[a]
            w[idx] = c
            he[a] = idx
            idx += 1

        def dijkstra(x):
            # èµ·å§‹å…ˆå°†æ‰€æœ‰çš„ç‚¹æ ‡è®°ä¸ºã€Œæœªæ›´æ–°ã€å’Œã€Œè·ç¦»ä¸ºæ­£æ— ç©·ã€
            dist = [float('inf')] * n
            vis = [False] * n
            dist[x] = 0
            # ä½¿ç”¨ã€Œä¼˜å…ˆé˜Ÿåˆ—ã€å­˜å‚¨æ‰€æœ‰å¯ç”¨äºæ›´æ–°çš„ç‚¹
            # ä»¥ (ç‚¹ç¼–å·, åˆ°èµ·ç‚¹çš„è·ç¦») è¿›è¡Œå­˜å‚¨ï¼Œä¼˜å…ˆå¼¹å‡ºã€Œæœ€çŸ­è·ç¦»ã€è¾ƒå°çš„ç‚¹
            q = [(0, x)]
            heapq.heapify(q)
            while q:
                # æ¯æ¬¡ä»ã€Œä¼˜å…ˆé˜Ÿåˆ—ã€ä¸­å¼¹å‡º
                step, u = heapq.heappop(q)
                # å¦‚æœå¼¹å‡ºçš„ç‚¹è¢«æ ‡è®°ã€Œå·²æ›´æ–°ã€ï¼Œåˆ™è·³è¿‡
                if vis[u]: continue
                # æ ‡è®°è¯¥ç‚¹ã€Œå·²æ›´æ–°ã€ï¼Œå¹¶ä½¿ç”¨è¯¥ç‚¹æ›´æ–°å…¶ä»–ç‚¹çš„ã€Œæœ€çŸ­è·ç¦»ã€
                vis[u] = True
                i = he[u]
                while i != -1:
                    j, c = e[i], w[i]
                    i = ne[i]
                    if dist[j] <= dist[u] + c: continue
                    dist[j] = dist[u] + c
                    heapq.heappush(q, (dist[j], j))
            return dist

        # åˆå§‹åŒ–é“¾è¡¨å¤´
        he = [-1] * N
        # å­˜å›¾
        for a, b, c in edges:
            add(a, b, c)
            add(b, a, c)
        # ç»Ÿè®¡ç­”æ¡ˆ
        ans, cnt = -1, n + 10
        for i in range(n):
            # å•æºæœ€çŸ­è·¯
            dist = dijkstra(i)
            cur = sum(1 for j in range(n) if i != j and dist[j] <= distanceThreshold)
            if cur <= cnt:
                cnt, ans = cur, i
        return ans
```
* æ—¶é—´å¤æ‚åº¦ï¼šåˆå§‹åŒ–é‚»æ¥è¡¨å’Œå»ºå›¾å¤æ‚åº¦ä¸º $O(n + m)$ï¼›ç»Ÿè®¡ç­”æ¡ˆæ—¶ï¼Œå…±æ‰§è¡Œ $n$ æ¬¡å †ä¼˜åŒ– `dijkstra` ç®—æ³•ï¼Œå †ä¼˜åŒ– `dijkstra` å¤æ‚åº¦ä¸º $O(m\log{n})$ï¼Œæ€»å¤æ‚åº¦ä¸º $O(nm\log{n})$ã€‚æ•´ä½“å¤æ‚åº¦ä¸º $O(nm\log{n})$
* ç©ºé—´å¤æ‚åº¦ï¼š$O(n + m)$

---

### Bellman Fordï¼ˆç±»ï¼‰

è™½ç„¶é¢˜ç›®è§„å®šäº†ä¸å­˜åœ¨ã€Œè´Ÿæƒè¾¹ã€ï¼Œä½†æˆ‘ä»¬ä»ç„¶å¯ä»¥ä½¿ç”¨å¯ä»¥åœ¨ã€Œè´Ÿæƒå›¾ä¸­æ±‚æœ€çŸ­è·¯ã€çš„ `Bellman Ford` è¿›è¡Œæ±‚è§£ï¼Œè¯¥ç®—æ³•ä¹Ÿæ˜¯ã€Œå•æºæœ€çŸ­è·¯ã€ç®—æ³•ï¼Œå¤æ‚åº¦ä¸º $O(n \times m)$ã€‚

é€šå¸¸ä¸ºäº†ç¡®ä¿ $O(n \times m)$ï¼Œå¯ä»¥å•ç‹¬å»ºä¸€ä¸ªç±»ä»£è¡¨è¾¹ï¼Œå°†æ‰€æœ‰è¾¹å­˜å…¥é›†åˆä¸­ï¼Œåœ¨ $n$ æ¬¡æ¾å¼›æ“ä½œä¸­ç›´æ¥å¯¹è¾¹é›†åˆè¿›è¡Œéå†ã€‚

ç”±äºæœ¬é¢˜è¾¹æ•°é‡çº§ä¸º $n^2$ï¼Œå…±å¯¹ $n$ ä¸ªç‚¹æ‰§è¡Œ `Bellman Ford` ç®—æ³•ï¼Œå› æ­¤æ•´ä½“ä¼šå»åˆ° $O(n^4)$ï¼Œæœ‰ `TLE` é£é™©ã€‚

Java ä»£ç ï¼š

```Java
class Solution {
    int n;
    public int findTheCity(int _n, int[][] edges, int distanceThreshold) {
        n = _n;
        int ans = -1, cnt = n + 10;
        for (int i = 0; i < n; i++) {
            int[] dist = bf(edges, i);
            int cur = 0;
            for (int j = 0; j < n; j++) {
                if (i != j && dist[j] <= distanceThreshold) cur++;
            }
            if (cur <= cnt) {
                cnt = cur; ans = i;
            }
        }
        return ans;
    }
    int[] bf(int[][] edges, int x) {
        int[] dist = new int[n];
        // èµ·å§‹å…ˆå°†æ‰€æœ‰çš„ç‚¹æ ‡è®°ä¸ºã€Œè·ç¦»ä¸ºæ­£æ— ç©·ã€, åªæœ‰èµ·ç‚¹æœ€çŸ­è·ç¦»ä¸º 0
        Arrays.fill(dist, 0x3f3f3f3f);
        dist[x] = 0;
        // æœ‰å¤šå°‘ä¸ªç‚¹å°±è¿­ä»£å¤šå°‘æ¬¡
        for (int k = 0; k < n; k++) {
            // æ¯æ¬¡éƒ½ä½¿ç”¨ä¸Šä¸€æ¬¡è¿­ä»£çš„ç»“æœï¼Œæ‰§è¡Œæ¾å¼›æ“ä½œ
            int[] prev = dist.clone();
            for (int[] e : edges) {
                int a = e[0], b = e[1], c = e[2];
                dist[b] = Math.min(dist[b], prev[a] + c);
                dist[a] = Math.min(dist[a], prev[b] + c);
            }
        }
        return dist;
    }
}
```
C++ ä»£ç ï¼š
```C++
class Solution {
public:
    int findTheCity(int n, vector<vector<int>>& edges, int distanceThreshold) {
        int ans = -1, cnt = n + 10;
        for (int i = 0; i < n; i++) {
            vector<int> dist = bf(edges, i, n);
            int cur = 0;
            for (int j = 0; j < n; j++) {
                if (i != j && dist[j] <= distanceThreshold) cur++;
            }
            if (cur <= cnt) {
                cnt = cur; ans = i;
            }
        }
        return ans;
    }
    vector<int> bf(vector<vector<int>>& edges, int x, int n) {
        // èµ·å§‹å…ˆå°†æ‰€æœ‰çš„ç‚¹æ ‡è®°ä¸ºã€Œè·ç¦»ä¸ºæ­£æ— ç©·ã€, åªæœ‰èµ·ç‚¹æœ€çŸ­è·ç¦»ä¸º 0
        vector<int> dist(n, 0x3f3f3f3f);
        dist[x] = 0;
        // æœ‰å¤šå°‘ä¸ªç‚¹å°±è¿­ä»£å¤šå°‘æ¬¡
        for (int k = 0; k < n; k++) {
            // æ¯æ¬¡éƒ½ä½¿ç”¨ä¸Šä¸€æ¬¡è¿­ä»£çš„ç»“æœï¼Œæ‰§è¡Œæ¾å¼›æ“ä½œ
            vector<int> prev = dist;
            for (const auto& e : edges) {
                int a = e[0], b = e[1], c = e[2];
                dist[b] = min(dist[b], prev[a] + c);
                dist[a] = min(dist[a], prev[b] + c);
            }
        }
        return dist;
    }
};
```
Python ä»£ç ï¼š
```Python
class Solution:
    def findTheCity(self, n: int, edges: List[List[int]], distanceThreshold: int) -> int:
        def bf(edges: List[List[int]], x: int, n: int) -> List[int]:
            # èµ·å§‹å…ˆå°†æ‰€æœ‰çš„ç‚¹æ ‡è®°ä¸ºã€Œè·ç¦»ä¸ºæ­£æ— ç©·ã€, åªæœ‰èµ·ç‚¹æœ€çŸ­è·ç¦»ä¸º 0
            dist = [float('inf')] * n
            dist[x] = 0
            # æœ‰å¤šå°‘ä¸ªç‚¹å°±è¿­ä»£å¤šå°‘æ¬¡
            for k in range(n):
                # æ¯æ¬¡éƒ½ä½¿ç”¨ä¸Šä¸€æ¬¡è¿­ä»£çš„ç»“æœï¼Œæ‰§è¡Œæ¾å¼›æ“ä½œ
                prev = dist.copy()
                for a, b, c in edges:
                    dist[b] = min(dist[b], prev[a] + c)
                    dist[a] = min(dist[a], prev[b] + c)
            return dist

        ans, cnt = -1, n + 10
        for i in range(n):
            dist = bf(edges, i, n)
            cur = sum(1 for j in range(n) if i != j and dist[j] <= distanceThreshold)
            if cur <= cnt:
                cnt, ans = cur, i
        return ans
```
TypeScript ä»£ç ï¼š
```TypeScript
function findTheCity(n: number, edges: number[][], distanceThreshold: number): number {
    const bf = function(x: number): number[] {
        // èµ·å§‹å…ˆå°†æ‰€æœ‰çš„ç‚¹æ ‡è®°ä¸ºã€Œè·ç¦»ä¸ºæ­£æ— ç©·ã€, åªæœ‰èµ·ç‚¹æœ€çŸ­è·ç¦»ä¸º 0
        const dist = new Array(n).fill(0x3f3f3f3f);
        dist[x] = 0;
        // æœ‰å¤šå°‘ä¸ªç‚¹å°±è¿­ä»£å¤šå°‘æ¬¡
        for (let k = 0; k < n; k++) {
            // æ¯æ¬¡éƒ½ä½¿ç”¨ä¸Šä¸€æ¬¡è¿­ä»£çš„ç»“æœï¼Œæ‰§è¡Œæ¾å¼›æ“ä½œ
            const prev = dist.slice();
            for (const e of edges) {
                const a = e[0], b = e[1], c = e[2];
                dist[b] = Math.min(dist[b], prev[a] + c);
                dist[a] = Math.min(dist[a], prev[b] + c);
            }
        }
        return dist;
    }

    let ans = -1, cnt = n + 10;
    for (let i = 0; i < n; i++) {
        const dist = bf(i);
        let cur = 0;
        for (let j = 0; j < n; j++) {
            if (i !== j && dist[j] <= distanceThreshold) cur++;
        }
        if (cur <= cnt) {
            cnt = cur; ans = i;
        }
    }
    return ans;
};
```
* æ—¶é—´å¤æ‚åº¦ï¼šç»Ÿè®¡ç­”æ¡ˆæ—¶ï¼Œå…±æ‰§è¡Œ $n$ æ¬¡ `Bellman Ford` ç®—æ³•ï¼Œ `Bellman Ford` å¤æ‚åº¦ä¸º $O(nm)$ï¼Œæ€»å¤æ‚åº¦ä¸º $O(n^2 \times m)$ã€‚æ•´ä½“å¤æ‚åº¦ä¸º $O(n^2 \times m)$
* ç©ºé—´å¤æ‚åº¦ï¼š$O(n + m)$

---

### SPFAï¼ˆé‚»æ¥è¡¨ï¼‰

`SPFA` ä¹Ÿæ˜¯ä¸€ç±»èƒ½å¤Ÿå¤„ç†ã€Œè´Ÿæƒè¾¹ã€çš„å•æºæœ€çŸ­è·¯ç®—æ³•ã€‚

æœ€åæƒ…å†µä¸‹ï¼Œå¤æ‚åº¦ä¸º $O(n \times m)$ï¼Œåœ¨ç‰¹å®šæƒ…å†µä¸‹ï¼Œå…¶æ•ˆç‡ä¼˜äº `Dijkstra` ç®—æ³•ï¼Œè¿‘ä¼¼ $O(m)$ã€‚

åŸºæœ¬æ‰§è¡Œæµç¨‹å¦‚ä¸‹ï¼š

1. ç”¨åŒç«¯é˜Ÿåˆ—æ¥ç»´æŠ¤å¾…æ›´æ–°èŠ‚ç‚¹ï¼Œåˆå§‹å°†æºç‚¹æ”¾å…¥é˜Ÿåˆ—
2. æ¯æ¬¡ä»é˜Ÿåˆ—å¤´ä¸­å–å‡ºä¸€ä¸ªèŠ‚ç‚¹ï¼Œå¯¹å…¶æ‰€æœ‰ç›¸é‚»èŠ‚ç‚¹æ‰§è¡Œæ¾å¼›æ“ä½œ
   1. è‹¥æŸä¸ªç›¸é‚»èŠ‚ç‚¹çš„æœ€çŸ­è·ç¦»å‘ç”Ÿäº†æ›´æ–°ï¼Œä¸”è¯¥èŠ‚ç‚¹ä¸åœ¨é˜Ÿåˆ—ä¸­ï¼Œå°†å®ƒåŠ å…¥é˜Ÿåˆ—ä¸­

3. é‡å¤ä»¥ä¸Šæ­¥éª¤ï¼Œç›´åˆ°é˜Ÿåˆ—ä¸ºç©º

Java ä»£ç ï¼š
```Java
class Solution {
    int N = 110, M = N * N, INF = 0x3f3f3f3f, idx, n;
    int[] he = new int[N], e = new int[M], ne = new int[M], w = new int[M];
    void add(int a, int b, int c) {
        e[idx] = b;
        ne[idx] = he[a];
        w[idx] = c;
        he[a] = idx++;
    }
    public int findTheCity(int _n, int[][] edges, int distanceThreshold) {
        n = _n;
        // åˆå§‹åŒ–é“¾è¡¨å¤´
        Arrays.fill(he, -1);
        // å­˜å›¾
        for (int[] e : edges) {
            int a = e[0], b = e[1], c = e[2];
            add(a, b, c); add(b, a, c);
        }
        // ç»Ÿè®¡ç­”æ¡ˆ
        int ans = -1, cnt = n + 10;
        for (int i = 0; i < n; i++) {
            // å•æºæœ€çŸ­è·¯
            int[] dist = spfa(i);
            int cur = 0;
            for (int j = 0; j < n; j++) {
                if (i != j && dist[j] <= distanceThreshold) cur++;
            }
            if (cur <= cnt) {
                cnt = cur; ans = i;
            }
        }
        return ans;
    }
    int[] spfa(int x) {
        int[] dist = new int[n];
        boolean[] vis = new boolean[n];
        // èµ·å§‹å…ˆå°†æ‰€æœ‰çš„ç‚¹æ ‡è®°ä¸ºã€Œæœªå…¥é˜Ÿã€å’Œã€Œè·ç¦»ä¸ºæ­£æ— ç©·ã€
        Arrays.fill(dist, INF);
        // åªæœ‰èµ·ç‚¹æœ€çŸ­è·ç¦»ä¸º 0
        dist[x] = 0;
        // ä½¿ç”¨ã€ŒåŒç«¯é˜Ÿåˆ—ã€å­˜å‚¨ï¼Œå­˜å‚¨çš„æ˜¯ç‚¹ç¼–å·
        Deque<Integer> d = new ArrayDeque<>();
        // å°†ã€Œæºç‚¹/èµ·ç‚¹ã€è¿›è¡Œå…¥é˜Ÿï¼Œå¹¶æ ‡è®°ã€Œå·²å…¥é˜Ÿã€
        d.addLast(x);
        vis[x] = true;
        while (!d.isEmpty()) {
            // æ¯æ¬¡ä»ã€ŒåŒç«¯é˜Ÿåˆ—ã€ä¸­å–å‡ºï¼Œå¹¶æ ‡è®°ã€Œæœªå…¥é˜Ÿã€
            int u = d.pollFirst();
            vis[u] = false;
            // å°è¯•ä½¿ç”¨è¯¥ç‚¹ï¼Œæ›´æ–°å…¶ä»–ç‚¹çš„æœ€çŸ­è·ç¦»
            // å¦‚æœæ›´æ–°çš„ç‚¹ï¼Œæœ¬èº«ã€Œæœªå…¥é˜Ÿã€åˆ™åŠ å…¥é˜Ÿåˆ—ä¸­ï¼Œå¹¶æ ‡è®°ã€Œå·²å…¥é˜Ÿã€
            for (int i = he[u]; i != -1; i = ne[i]) {
                int j = e[i];
                if (dist[j] <= dist[u] + w[i]) continue;
                dist[j] = dist[u] + w[i];
                if (vis[j]) continue;
                d.addLast(j);
                vis[j] = true;
            }
        }
        return dist;
    }
}
```
C++ ä»£ç ï¼š
```C++
class Solution {
public:
    static const int N = 110, M = N * N;
    int he[N], e[M], ne[M], w[M], idx, n, INF = 0x3f3f3f3f;
    void add(int a, int b, int c) {
        e[idx] = b;
        ne[idx] = he[a];
        w[idx] = c;
        he[a] = idx++;
    }
    int findTheCity(int _n, vector<vector<int>>& edges, int distanceThreshold) {
        n = _n;
        fill(he, he + N, -1);
        for (const auto& e : edges) {
            int a = e[0], b = e[1], c = e[2];
            add(a, b, c); add(b, a, c);
        }
        int ans = -1, cnt = n + 10;
        for (int i = 0; i < n; i++) {
            vector<int> dist = spfa(i);
            int cur = count_if(dist.begin(), dist.end(), [&](int d) { return d != INF && d <= distanceThreshold; });
            if (cur <= cnt) {
                cnt = cur; ans = i;
            }
        }
        return ans;
    }
    vector<int> spfa(int x) {
        // èµ·å§‹å…ˆå°†æ‰€æœ‰çš„ç‚¹æ ‡è®°ä¸ºã€Œæœªå…¥é˜Ÿã€å’Œã€Œè·ç¦»ä¸ºæ­£æ— ç©·ã€
        vector<int> dist(n, INF);
        vector<bool> vis(n, false);
        // åªæœ‰èµ·ç‚¹æœ€çŸ­è·ç¦»ä¸º 0
        dist[x] = 0;
        // ä½¿ç”¨ã€ŒåŒç«¯é˜Ÿåˆ—ã€å­˜å‚¨ï¼Œå­˜å‚¨çš„æ˜¯ç‚¹ç¼–å·
        deque<int> d;
        // å°†ã€Œæºç‚¹/èµ·ç‚¹ã€è¿›è¡Œå…¥é˜Ÿï¼Œå¹¶æ ‡è®°ã€Œå·²å…¥é˜Ÿã€
        d.push_back(x);
        vis[x] = true;
        while (!d.empty()) {
            // æ¯æ¬¡ä»ã€ŒåŒç«¯é˜Ÿåˆ—ã€ä¸­å–å‡ºï¼Œå¹¶æ ‡è®°ã€Œæœªå…¥é˜Ÿã€
            int u = d.front();
            d.pop_front();
            vis[u] = false;
            // å°è¯•ä½¿ç”¨è¯¥ç‚¹ï¼Œæ›´æ–°å…¶ä»–ç‚¹çš„æœ€çŸ­è·ç¦»
            // å¦‚æœæ›´æ–°çš„ç‚¹ï¼Œæœ¬èº«ã€Œæœªå…¥é˜Ÿã€åˆ™åŠ å…¥é˜Ÿåˆ—ä¸­ï¼Œå¹¶æ ‡è®°ã€Œå·²å…¥é˜Ÿã€
            for (int i = he[u]; i != -1; i = ne[i]) {
                int j = e[i];
                if (dist[j] <= dist[u] + w[i]) continue;
                dist[j] = dist[u] + w[i];
                if (vis[j]) continue;
                d.push_back(j);
                vis[j] = true;
            }
        }
        return dist;
    }
};
```
Python ä»£ç ï¼š
```Python
class Solution:
    def findTheCity(self, n: int, edges: List[List[int]], distanceThreshold: int) -> int:
        m, INF, idx = n * n, 0x3f3f3f3f, 0
        he, e, ne, w = [-1] * n, [0] * m, [0] * m, [0] * m

        def add(a: int, b: int, c: int):
            nonlocal idx
            e[idx] = b
            ne[idx] = he[a]
            w[idx] = c
            he[a] = idx
            idx += 1

        def spfa(x: int) -> List[int]:
            # èµ·å§‹å…ˆå°†æ‰€æœ‰çš„ç‚¹æ ‡è®°ä¸ºã€Œæœªå…¥é˜Ÿã€å’Œã€Œè·ç¦»ä¸ºæ­£æ— ç©·ã€
            dist = [INF] * n
            vis = [False] * n
            # åªæœ‰èµ·ç‚¹æœ€çŸ­è·ç¦»ä¸º 0
            dist[x] = 0
            # ä½¿ç”¨ã€ŒåŒç«¯é˜Ÿåˆ—ã€å­˜å‚¨ï¼Œå­˜å‚¨çš„æ˜¯ç‚¹ç¼–å·
            d = deque()
            # å°†ã€Œæºç‚¹/èµ·ç‚¹ã€è¿›è¡Œå…¥é˜Ÿï¼Œå¹¶æ ‡è®°ã€Œå·²å…¥é˜Ÿã€
            d.append(x)
            vis[x] = True
            while d:
                # æ¯æ¬¡ä»ã€ŒåŒç«¯é˜Ÿåˆ—ã€ä¸­å–å‡ºï¼Œå¹¶æ ‡è®°ã€Œæœªå…¥é˜Ÿã€
                u = d.popleft()
                vis[u] = False
                i = he[u]
                # å°è¯•ä½¿ç”¨è¯¥ç‚¹ï¼Œæ›´æ–°å…¶ä»–ç‚¹çš„æœ€çŸ­è·ç¦»
                # å¦‚æœæ›´æ–°çš„ç‚¹ï¼Œæœ¬èº«ã€Œæœªå…¥é˜Ÿã€åˆ™åŠ å…¥é˜Ÿåˆ—ä¸­ï¼Œå¹¶æ ‡è®°ã€Œå·²å…¥é˜Ÿã€
                while i != -1:
                    j, c = e[i], w[i]
                    i = ne[i]
                    if dist[j] <= dist[u] + c: continue
                    dist[j] = dist[u] + c
                    if vis[j]: continue
                    d.append(j)
                    vis[j] = True
            return dist

        for a, b, c in edges:
            add(a, b, c)
            add(b, a, c)

        ans, cnt = -1, n + 10
        for i in range(n):
            dist = spfa(i)
            cur = sum(1 for d in dist if d != INF and d <= distanceThreshold)
            if cur <= cnt:
                cnt, ans = cur, i
        return ans
```
* æ—¶é—´å¤æ‚åº¦ï¼šç»Ÿè®¡ç­”æ¡ˆæ—¶ï¼Œå…±æ‰§è¡Œ $n$ æ¬¡ `spfa` ç®—æ³•ï¼Œ `spfa` å¤æ‚åº¦ä¸º $O(nm)$ï¼Œæ€»å¤æ‚åº¦ä¸º $O(n^2 \times m)$ã€‚æ•´ä½“å¤æ‚åº¦ä¸º $O(n^2 \times m)$
* ç©ºé—´å¤æ‚åº¦ï¼š$O(n + m)$

---

### æœ€å

è¿™æ˜¯æˆ‘ä»¬ã€Œåˆ·ç©¿ LeetCodeã€ç³»åˆ—æ–‡ç« çš„ç¬¬ `No.1334` ç¯‡ï¼Œç³»åˆ—å¼€å§‹äº 2021/01/01ï¼Œæˆªæ­¢äºèµ·å§‹æ—¥ LeetCode ä¸Šå…±æœ‰ 1916 é“é¢˜ç›®ï¼Œéƒ¨åˆ†æ˜¯æœ‰é”é¢˜ï¼Œæˆ‘ä»¬å°†å…ˆæŠŠæ‰€æœ‰ä¸å¸¦é”çš„é¢˜ç›®åˆ·å®Œã€‚

åœ¨è¿™ä¸ªç³»åˆ—æ–‡ç« é‡Œé¢ï¼Œé™¤äº†è®²è§£è§£é¢˜æ€è·¯ä»¥å¤–ï¼Œè¿˜ä¼šå°½å¯èƒ½ç»™å‡ºæœ€ä¸ºç®€æ´çš„ä»£ç ã€‚å¦‚æœæ¶‰åŠé€šè§£è¿˜ä¼šç›¸åº”çš„ä»£ç æ¨¡æ¿ã€‚

ä¸ºäº†æ–¹ä¾¿å„ä½åŒå­¦èƒ½å¤Ÿç”µè„‘ä¸Šè¿›è¡Œè°ƒè¯•å’Œæäº¤ä»£ç ï¼Œæˆ‘å»ºç«‹äº†ç›¸å…³çš„ä»“åº“ï¼šhttps://github.com/SharingSource/LogicStack-LeetCode ã€‚

åœ¨ä»“åº“åœ°å€é‡Œï¼Œä½ å¯ä»¥çœ‹åˆ°ç³»åˆ—æ–‡ç« çš„é¢˜è§£é“¾æ¥ã€ç³»åˆ—æ–‡ç« çš„ç›¸åº”ä»£ç ã€LeetCode åŸé¢˜é“¾æ¥å’Œå…¶ä»–ä¼˜é€‰é¢˜è§£ã€‚

