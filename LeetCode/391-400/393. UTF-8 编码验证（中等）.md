### 题目描述

这是 LeetCode 上的 **[393. UTF-8 编码验证](https://leetcode-cn.com/problems/utf-8-validation/solution/by-ac_oier-zvoy/)** ，难度为 **中等**。

Tag : 「模拟」



给定一个表示数据的整数数组 `data` ，返回它是否为有效的 $UTF-8$ 编码。

`UTF-8` 中的一个字符可能的长度为 $1$ 到 $4$ 字节，遵循以下的规则：

1. 对于 $1$ 字节 的字符，字节的第一位设为 $0$ ，后面 $7$ 位为这个符号的 `unicode` 码。
2. 对于 $n$ 字节 的字符 ($n > 1$)，第一个字节的前 $n$ 位都设为 $1$，第 $n+1$ 位设为 $0$ ，后面字节的前两位一律设为 $10$ 。剩下的没有提及的二进制位，全部为这个符号的 `unicode` 码。

这是 UTF-8 编码的工作方式：
```
   Char. number range  |        UTF-8 octet sequence
      (hexadecimal)    |              (binary)
   --------------------+---------------------------------------------
   0000 0000-0000 007F | 0xxxxxxx
   0000 0080-0000 07FF | 110xxxxx 10xxxxxx
   0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx
   0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
```
注意：输入是整数数组。只有每个整数的 最低 8 个有效位 用来存储数据。这意味着每个整数只表示 1 字节的数据。



示例 1：
```
输入：data = [197,130,1]

输出：true

解释：数据表示字节序列:11000101 10000010 00000001。
这是有效的 utf-8 编码，为一个 2 字节字符，跟着一个 1 字节字符。
```
示例 2：
```
输入：data = [235,140,4]

输出：false

解释：数据表示 8 位的序列: 11101011 10001100 00000100.
前 3 位都是 1 ，第 4 位为 0 表示它是一个 3 字节字符。
下一个字节是开头为 10 的延续字节，这是正确的。
但第二个延续字节不以 10 开头，所以是不符合规则的。
```

提示:
* $1 <= data.length <= 2 * 10^4$
* $0 <= data[i] <= 255$

---

### 模拟

根据题意进行模拟即可。

从前往后处理每个 $data[i]$，先统计 $data[i]$ 从第 $7$ 位开始往后有多少位连续的 $1$，代表这是一个几字节的字符，记为 $cnt$ ：

* 如果 $cnt$ 为 $1$ 或者大于 $4$ 均违反编码规则（与字符长度为 $1$ 时的编码规则 和 字符长度只能是 $1$ 到 $4$ 冲突），返回 `False`；
* 如果位置 $i$ 后面不足 $cnt - 1$ 也返回 `False`；
* 否则检查下标范围为 $[i + 1, i + cnt - 1]$ 的数是否满足前两位为 $10$ 的要求，若不满足返回 `False`。

如果上述过程满足要求，跳到下一个检查点进行检查，整个 `data` 都没有冲突则返回 `True`。

代码：
```Java
class Solution {
    public boolean validUtf8(int[] data) {
        int n = data.length;
        for (int i = 0; i < n; ) {
            int t = data[i], j = 7;
            while (j >= 0 && (((t >> j) & 1) == 1)) j--;
            int cnt = 7 - j;
            if (cnt == 1 || cnt > 4) return false;
            if (i + cnt - 1 >= n) return false;
            for (int k = i + 1; k < i + cnt; k++) {
                if ((((data[k] >> 7) & 1) == 1) && (((data[k] >> 6) & 1) == 0)) continue;
                return false;
            }
            if (cnt == 0) i++;
            else i += cnt;
        }
        return true;
    }
}
```
* 时间复杂度：$O(n)$
* 空间复杂度：$O(1)$

---

### 最后

这是我们「刷穿 LeetCode」系列文章的第 `No.393` 篇，系列开始于 2021/01/01，截止于起始日 LeetCode 上共有 1916 道题目，部分是有锁题，我们将先把所有不带锁的题目刷完。

在这个系列文章里面，除了讲解解题思路以外，还会尽可能给出最为简洁的代码。如果涉及通解还会相应的代码模板。

为了方便各位同学能够电脑上进行调试和提交代码，我建立了相关的仓库：https://github.com/SharingSource/LogicStack-LeetCode 。

在仓库地址里，你可以看到系列文章的题解链接、系列文章的相应代码、LeetCode 原题链接和其他优选题解。

