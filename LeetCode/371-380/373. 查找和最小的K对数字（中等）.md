### é¢˜ç›®æè¿°

è¿™æ˜¯ LeetCode ä¸Šçš„ **[373. æŸ¥æ‰¾å’Œæœ€å°çš„Kå¯¹æ•°å­—](https://leetcode-cn.com/problems/find-k-pairs-with-smallest-sums/solution/gong-shui-san-xie-duo-lu-gui-bing-yun-yo-pgw5/)** ï¼Œéš¾åº¦ä¸º **ä¸­ç­‰**ã€‚

Tag : ã€Œä¼˜å…ˆé˜Ÿåˆ—ã€ã€ã€ŒäºŒåˆ†ã€ã€ã€Œå¤šè·¯å½’å¹¶ã€



ç»™å®šä¸¤ä¸ªä»¥å‡åºæ’åˆ—çš„æ•´æ•°æ•°ç»„ `nums1` å’Œ `nums2`Â ,Â ä»¥åŠä¸€ä¸ªæ•´æ•° `k`Â ã€‚

å®šä¹‰ä¸€å¯¹å€¼Â $(u,v)$ï¼Œå…¶ä¸­ç¬¬ä¸€ä¸ªå…ƒç´ æ¥è‡ªÂ `nums1`ï¼Œç¬¬äºŒä¸ªå…ƒç´ æ¥è‡ª `nums2`ã€‚

è¯·æ‰¾åˆ°å’Œæœ€å°çš„ `k`Â ä¸ªæ•°å¯¹Â $(u_1,v_1), Â (u_2,v_2) Â ... Â (u_k,v_k)$Â ã€‚Â 

ç¤ºä¾‹ 1:
```
è¾“å…¥: nums1 = [1,7,11], nums2 = [2,4,6], k = 3

è¾“å‡º: [1,2],[1,4],[1,6]

è§£é‡Š: è¿”å›åºåˆ—ä¸­çš„å‰ 3 å¯¹æ•°ï¼š
     [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]
```
ç¤ºä¾‹ 2:
```
è¾“å…¥: nums1 = [1,1,2], nums2 = [1,2,3], k = 2

è¾“å‡º: [1,1],[1,1]

è§£é‡Š: è¿”å›åºåˆ—ä¸­çš„å‰ 2 å¯¹æ•°ï¼š
Â     [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]
```
ç¤ºä¾‹ 3:
```
è¾“å…¥: nums1 = [1,2], nums2 = [3], k = 3 

è¾“å‡º: [1,3],[2,3]

è§£é‡Š: ä¹Ÿå¯èƒ½åºåˆ—ä¸­æ‰€æœ‰çš„æ•°å¯¹éƒ½è¢«è¿”å›:[1,3],[2,3]
```

æç¤º:
* $1 <= nums1.length, nums2.length <= 10^4$
* $-10^9 <= nums1[i], nums2[i] <= 10^9$
* $nums1, nums2 å‡ä¸ºå‡åºæ’åˆ—$
* $1 <= k <= 1000$

---

### åŸºæœ¬åˆ†æ 

è¿™é“é¢˜å’Œ [(é¢˜è§£) 786. ç¬¬ K ä¸ªæœ€å°çš„ç´ æ•°åˆ†æ•°](https://leetcode-cn.com/problems/k-th-smallest-prime-fraction/solution/gong-shui-san-xie-yi-ti-shuang-jie-you-x-8ymk/) å‡ ä¹æ˜¯ä¸€æ¨¡ä¸€æ ·ï¼Œå…ˆåšå“ªä¸€é“éƒ½æ˜¯ä¸€æ ·çš„ï¼Œéš¾åº¦ä¸Šæ²¡æœ‰åŒºåˆ« ğŸ¤£ 

æœ€å¸¸è§„çš„åšæ³•æ˜¯ä½¿ç”¨ã€Œå¤šè·¯å½’å¹¶ã€ï¼Œè¿˜ä¸ç†Ÿæ‚‰ã€Œå¤šè·¯å½’å¹¶ã€çš„åŒå­¦ï¼Œå»ºè®®å…ˆå­¦ä¹ å‰ç½®ğŸ§€ï¼š[å¤šè·¯å½’å¹¶å…¥é—¨](https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&mid=2247490029&idx=1&sn=bba9ddff88d247db310406ee418d5a15&chksm=fd9cb2f2caeb3be4b1f84962677337dcb5884374e5b6b80340834eaff79298d11151da2dd5f7&token=252055586&lang=zh_CN#rd)ï¼Œé‡Œé¢è®²è¿°äº†å¦‚ä½•ä»ã€Œæœ´ç´ ä¼˜å…ˆé˜Ÿåˆ—ã€å¾€ã€Œå¤šè·¯å½’å¹¶ã€è¿›è¡Œè½¬æ¢ã€‚

---

### å¤šè·¯å½’å¹¶

ä»¤ $nums1$ çš„é•¿åº¦ä¸º $n$ï¼Œ$nums2$ çš„é•¿åº¦ä¸º $m$ï¼Œæ‰€æœ‰çš„ç‚¹å¯¹æ•°é‡ä¸º $n * m$ã€‚

å…¶ä¸­æ¯ä¸ª $nums1[i]$ å‚ä¸æ‰€ç»„æˆçš„ç‚¹åºåˆ—ä¸ºï¼š

$$
[(nums1[0], nums2[0]), (nums1[0], nums2[1]), ..., (nums1[0], nums2[m - 1])]\\
[(nums1[1], nums2[0]), (nums1[1], nums2[1]), ..., (nums1[1], nums2[m - 1])]\\
...\\
[(nums1[n - 1], nums2[0]), (nums1[n - 1], nums2[1]), ..., (nums1[n - 1], nums2[m - 1])]\\
$$

ç”±äº $nums1$ å’Œ $nums2$ å‡å·²æŒ‰å‡åºæ’åºï¼Œå› æ­¤æ¯ä¸ª $nums1[i]$ å‚ä¸æ„æˆçš„ç‚¹åºåˆ—ä¹Ÿä¸ºå‡åºæ’åºï¼Œè¿™å¼•å¯¼æˆ‘ä»¬ä½¿ç”¨ã€Œå¤šè·¯å½’å¹¶ã€æ¥è¿›è¡Œæ±‚è§£ã€‚

å…·ä½“çš„ï¼Œèµ·å§‹æˆ‘ä»¬å°†è¿™ $n$ ä¸ªåºåˆ—çš„é¦–ä½å…ƒç´ ï¼ˆç‚¹å¯¹ï¼‰ä»¥äºŒå…ƒç»„ $(i, j)$ æ”¾å…¥ä¼˜å…ˆé˜Ÿåˆ—ï¼ˆå°æ ¹å †ï¼‰ï¼Œå…¶ä¸­ $i$ ä¸ºè¯¥ç‚¹å¯¹ä¸­ $nums1[i]$ çš„ä¸‹æ ‡ï¼Œ$j$ ä¸ºè¯¥ç‚¹å¯¹ä¸­ $nums2[j]$ çš„ä¸‹æ ‡ï¼Œè¿™æ­¥æ“ä½œçš„å¤æ‚åº¦ä¸º $O(n\log{n})$ã€‚è¿™é‡Œä¹Ÿå¯ä»¥å¾—å‡ºä¸€ä¸ªå°ä¼˜åŒ–æ˜¯ï¼šæˆ‘ä»¬å§‹ç»ˆç¡®ä¿ $nums1$ ä¸ºä¸¤æ•°ç»„ä¸­é•¿åº¦è¾ƒå°‘çš„é‚£ä¸ªï¼Œç„¶åé€šè¿‡æ ‡è¯†ä½æ¥è®°å½•æ˜¯å¦å‘ç”Ÿè¿‡äº¤æ¢ï¼Œç¡®ä¿ç­”æ¡ˆçš„ç‚¹é¡ºåºçš„æ­£ç¡®æ€§ã€‚

æ¯æ¬¡ä»ä¼˜å…ˆé˜Ÿåˆ—ï¼ˆå †ï¼‰ä¸­å–å‡ºå †é¡¶å…ƒç´ ï¼ˆå«ä¹‰ä¸ºå½“å‰æœªè¢«åŠ å…¥åˆ°ç­”æ¡ˆçš„æ‰€æœ‰ç‚¹å¯¹ä¸­çš„æœ€å°å€¼ï¼‰ï¼ŒåŠ å…¥ç­”æ¡ˆï¼Œå¹¶å°†è¯¥ç‚¹å¯¹æ‰€åœ¨åºåˆ—çš„ä¸‹ä¸€ä½ï¼ˆå¦‚æœæœ‰ï¼‰åŠ å…¥ä¼˜å…ˆé˜Ÿåˆ—ä¸­ã€‚

ä¸¾ä¸ª ğŸŒ°ï¼Œé¦–æ¬¡å–å‡ºçš„äºŒå…ƒç»„ä¸º $(0, 0)$ï¼Œå³ç‚¹å¯¹ $(nums1[0], nums2[0])$ï¼Œå–å®Œåå°†åºåˆ—çš„ä¸‹ä¸€ä½ç‚¹å¯¹ $(nums1[0], nums2[1])$ ä»¥äºŒå…ƒç»„ $(0, 1)$ å½¢å¼æ”¾å…¥ä¼˜å…ˆé˜Ÿåˆ—ã€‚

å¯é€šè¿‡ã€Œåè¯æ³•ã€è¯æ˜ï¼Œæ¯æ¬¡è¿™æ ·çš„ã€Œå–å½“å‰ï¼Œæ”¾å…¥ä¸‹ä¸€ä½ã€çš„æ“ä½œï¼Œå¯ä»¥ç¡®ä¿å½“å‰æœªè¢«åŠ å…¥ç­”æ¡ˆçš„æ‰€æœ‰ç‚¹å¯¹çš„æœ€å°å€¼å¿…ç„¶åœ¨ä¼˜å…ˆé˜Ÿåˆ—ï¼ˆå †ï¼‰ä¸­ï¼Œå³å‰ $k$ ä¸ªå‡ºå †çš„å…ƒç´ å¿…ç„¶æ˜¯æ‰€æœ‰ç‚¹å¯¹çš„å‰ $k$ å°çš„å€¼ã€‚

**ä»£ç ï¼ˆæ„Ÿè°¢ [@Benhao](/u/himymben/) åŒå­¦æä¾›çš„å…¶ä»–è¯­è¨€ç‰ˆæœ¬ï¼‰ï¼š**
```Java
class Solution {
    boolean flag = true;
    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {
        List<List<Integer>> ans = new ArrayList<>();
        int n = nums1.length, m = nums2.length;
        if (n > m && !(flag = false)) return kSmallestPairs(nums2, nums1, k);
        PriorityQueue<int[]> q = new PriorityQueue<>((a,b)->(nums1[a[0]]+nums2[a[1]])-(nums1[b[0]]+nums2[b[1]]));
        for (int i = 0; i < Math.min(n, k); i++) q.add(new int[]{i, 0});
        while (ans.size() < k && !q.isEmpty()) {
            int[] poll = q.poll();
            int a = poll[0], b = poll[1];
            ans.add(new ArrayList<>(){{
                add(flag ? nums1[a] : nums2[b]);
                add(flag ? nums2[b] : nums1[a]);
            }});
            if (b + 1 < m) q.add(new int[]{a, b + 1});
        }
        return ans;
    }
}
```
-
```Python3
class Solution:
    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:
        flag, ans = (n := len(nums1)) > (m := len(nums2)), []
        if flag:
            n, m, nums1, nums2 = m, n, nums2, nums1
        pq = []
        for i in range(min(n, k)):
            heapq.heappush(pq, (nums1[i] + nums2[0], i, 0))
        while len(ans) < k and pq:
            _, a, b = heapq.heappop(pq)
            ans.append([nums2[b], nums1[a]] if flag else [nums1[a], nums2[b]])
            if b + 1 < m:
                heapq.heappush(pq, (nums1[a] + nums2[b + 1], a, b + 1))
        return ans
```
-
```Golang
func kSmallestPairs(nums1 []int, nums2 []int, k int) [][]int {
    n, m, ans := len(nums1), len(nums2), [][]int{}
    flag := n > m
    if flag {
        n, m, nums1, nums2 = m, n, nums2, nums1
    }
    if n > k {
        n = k
    }
    pq := make(hp, n)
    for i := 0; i < n; i++ {
        pq[i] = []int{nums1[i] + nums2[0], i, 0}
    }
    heap.Init(&pq)
    for pq.Len() > 0 && len(ans) < k {
        poll := heap.Pop(&pq).([]int)
        a, b := poll[1], poll[2] 
        if flag{
            ans = append(ans, []int{nums2[b], nums1[a]})
        }else{
            ans = append(ans, []int{nums1[a], nums2[b]})
        }
        if b < m - 1 {
            heap.Push(&pq, []int{nums1[a] + nums2[b + 1], a, b + 1})
        }
    }
    return ans
}
// æœ€å°å †æ¨¡æ¿
type hp [][]int
func (h hp) Len() int            { return len(h) }
func (h hp) Less(i, j int) bool  { return h[i][0] < h[j][0] }
func (h hp) Swap(i, j int)       { h[i], h[j] = h[j], h[i] }
func (h *hp) Push(v interface{}) { *h = append(*h, v.([]int)) }
func (h *hp) Pop() interface{}   { a := *h; v := a[len(a)-1]; *h = a[:len(a)-1]; return v }
```
* æ—¶é—´å¤æ‚åº¦ï¼šä»¤ $M$ ä¸º $n$ã€$m$ å’Œ $k$ ä¸‰è€…ä¸­çš„æœ€å°å€¼ï¼Œå¤æ‚åº¦ä¸º $O(M + k) * \log{M})$
* ç©ºé—´å¤æ‚åº¦ï¼š$O(M)$

---

### äºŒåˆ†

æˆ‘ä»¬è¿˜èƒ½å¤Ÿä½¿ç”¨å¤šæ¬¡ã€ŒäºŒåˆ†ã€æ¥åšã€‚

å‡è®¾æˆ‘ä»¬å°†æ‰€æœ‰ã€Œæ•°å¯¹å’Œã€æŒ‰ç…§å‡åºæ’åºï¼Œä¸¤ç«¯çš„å€¼åˆ†åˆ«ä¸º $l = nums1[0] + nums2[0]$ å’Œ $r = nums1[n - 1] + nums2[m - 1]$ã€‚

å› æ­¤æˆ‘ä»¬å¯ä»¥åœ¨å€¼åŸŸ $[l, r]$ ä¸Šè¿›è¡ŒäºŒåˆ†ï¼Œæ‰¾åˆ°ç¬¬ä¸€ä¸ªæ»¡è¶³ã€Œç‚¹å¯¹å’Œå°äºç­‰äº $x$ çš„ï¼Œä¸”æ•°é‡è¶…è¿‡ $k$ çš„å€¼ $x$ã€ã€‚

ä¹‹æ‰€ä»¥èƒ½å¤ŸäºŒåˆ†ï¼Œæ˜¯å› ä¸º $x$ æ‰€åœ¨çš„ç‚¹å¯¹å’Œæ•°è½´ä¸Šå…·æœ‰äºŒæ®µæ€§ï¼š

* ç‚¹å¯¹å’Œå°äº $x$ çš„ç‚¹å¯¹æ•°é‡å°‘äº $k$ ä¸ªï¼›
* ç‚¹å¯¹å’Œå¤§äºç­‰äº $x$ çš„ç‚¹å¯¹æ•°é‡å¤§äºç­‰äº $k$ ä¸ªã€‚

åˆ¤å®šå°äºç­‰äº $x$ çš„ç‚¹å¯¹æ•°é‡æ˜¯å¦å¤§äºç­‰äº $k$ ä¸ªè¿™ä¸€æ­¥å¯ç›´æ¥ä½¿ç”¨å¾ªç¯æ¥åšï¼Œç”±äºäºŒåˆ†æ˜¯ä»ä¸­é—´å€¼å¼€å§‹ï¼Œè¿™ä¸€æ­¥ä¸ä¼šå‡ºç°è·‘æ»¡ä¸¤å±‚å¾ªç¯çš„æƒ…å†µã€‚

å½“äºŒåˆ†å‡ºç¬¬ $k$ å°çš„å€¼ä¸º $x$ åï¼Œç”±äºå­˜åœ¨ä¸åŒç‚¹å¯¹çš„ç‚¹å¯¹å’Œå€¼ç›¸ç­‰ï¼Œæˆ‘ä»¬éœ€è¦å…ˆå°†æ‰€æœ‰ç‚¹å¯¹å’Œå°äºç­‰äº $x$ çš„å€¼åŠ å…¥ç­”æ¡ˆï¼Œç„¶åé…Œæƒ…æŠŠå€¼ç­‰äº $x$ çš„ç‚¹å¯¹åŠ å…¥ç­”æ¡ˆï¼ŒçŸ¥é“æ»¡è¶³ç­”æ¡ˆæ•°é‡ä¸º $k$ã€‚

æ‰¾å€¼ä¸º $x$ çš„æ‰€æœ‰ç‚¹å¯¹è¿™ä¸€æ­¥ï¼Œå¯ä»¥é€šè¿‡æšä¸¾ $nums1[i]$ï¼Œç„¶ååœ¨ $nums2$ ä¸ŠäºŒåˆ†ç›®æ ‡å€¼ $x - nums1[i]$ çš„å·¦å³ç«¯ç‚¹æ¥åšã€‚

æœ€åï¼Œåœ¨æ‰€æœ‰å¤„ç†è¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬éƒ½å¯ä»¥åˆ©ç”¨ç­”æ¡ˆæ•°ç»„çš„å¤§å°ä¸ $k$ çš„å…³ç³»åšå‰ªæã€‚

ä»£ç ï¼š
```Java
class Solution {
    int[] nums1, nums2;
    int n, m;
    public List<List<Integer>> kSmallestPairs(int[] n1, int[] n2, int k) {
        nums1 = n1; nums2 = n2;
        n = nums1.length; m = nums2.length;
        List<List<Integer>> ans = new ArrayList<>();
        int l = nums1[0] + nums2[0], r = nums1[n - 1] + nums2[m - 1];
        while (l < r) {
            int mid = (int)(0L + l + r >> 1);
            if (check(mid, k)) r = mid;
            else l = mid + 1;
        }
        int x = r;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (nums1[i] + nums2[j] < x) {
                    List<Integer> temp = new ArrayList<>();
                    temp.add(nums1[i]); temp.add(nums2[j]);
                    ans.add(temp);
                } else break;
            }
        }
        for (int i = 0; i < n && ans.size() < k; i++) {
            int a = nums1[i], b = x - a;
            int c = -1, d = -1;
            l = 0; r = m - 1;
            while (l < r) {
                int mid = (int)(0L + l + r >> 1);
                if (nums2[mid] >= b) r = mid;
                else l = mid + 1;
            }
            if (nums2[r] != b) continue;
            c = r;
            l = 0; r = m - 1;
            while (l < r) {
                int mid = (int)(0L + l + r + 1) >> 1;
                if (nums2[mid] <= b) l = mid;
                else r = mid - 1;
            }
            d = r;
            for (int p = c; p <= d && ans.size() < k; p++) {
                List<Integer> temp = new ArrayList<>();
                temp.add(a); temp.add(b);
                ans.add(temp);
            }
        }
        return ans;
    }
    boolean check(int x, int k) {
        int ans = 0;
        for (int i = 0; i < n && ans < k; i++) {
            for (int j = 0; j < m && ans < k; j++) {
                if (nums1[i] + nums2[j] <= x) ans++;
                else break;
            }
        }
        return ans >= k;
    }
}
```
* æ—¶é—´å¤æ‚åº¦ï¼šå‡è®¾ç‚¹å¯¹å’Œçš„å€¼åŸŸå¤§å°èŒƒå›´ä¸º $M$ï¼Œç¬¬ä¸€æ¬¡äºŒåˆ†çš„å¤æ‚åº¦ä¸º $O((n * m) * \log{M})$ï¼›ç»Ÿè®¡ç‚¹å¯¹å’Œå€¼å°äºç›®æ ‡å€¼ $x$ çš„å¤æ‚åº¦ä¸º $O(n * m)$ï¼›ç»Ÿè®¡æ‰€æœ‰ç‚¹å¯¹å’Œç­‰äºç›®æ ‡å€¼çš„å¤æ‚åº¦ä¸º $O(\max(n * \log{m}, k))$ï¼ˆæ•´ä¸ªå¤„ç†è¿‡ç¨‹ä¸­åˆ©ç”¨äº†å¤§å°å…³ç³»åšäº†å‰ªæï¼Œå¤§å¤šå¾ªç¯éƒ½ä¸ä¼šè·‘æ»¡ï¼Œå®é™…è®¡ç®—é‡ä¼šæ¯”ç†è®ºåˆ†æçš„è¦ä½ï¼‰
* ç©ºé—´å¤æ‚åº¦ï¼š$O(k)$

---

### æœ€å

è¿™æ˜¯æˆ‘ä»¬ã€Œåˆ·ç©¿ LeetCodeã€ç³»åˆ—æ–‡ç« çš„ç¬¬ `No.373` ç¯‡ï¼Œç³»åˆ—å¼€å§‹äº 2021/01/01ï¼Œæˆªæ­¢äºèµ·å§‹æ—¥ LeetCode ä¸Šå…±æœ‰ 1916 é“é¢˜ç›®ï¼Œéƒ¨åˆ†æ˜¯æœ‰é”é¢˜ï¼Œæˆ‘ä»¬å°†å…ˆæŠŠæ‰€æœ‰ä¸å¸¦é”çš„é¢˜ç›®åˆ·å®Œã€‚

åœ¨è¿™ä¸ªç³»åˆ—æ–‡ç« é‡Œé¢ï¼Œé™¤äº†è®²è§£è§£é¢˜æ€è·¯ä»¥å¤–ï¼Œè¿˜ä¼šå°½å¯èƒ½ç»™å‡ºæœ€ä¸ºç®€æ´çš„ä»£ç ã€‚å¦‚æœæ¶‰åŠé€šè§£è¿˜ä¼šç›¸åº”çš„ä»£ç æ¨¡æ¿ã€‚

ä¸ºäº†æ–¹ä¾¿å„ä½åŒå­¦èƒ½å¤Ÿç”µè„‘ä¸Šè¿›è¡Œè°ƒè¯•å’Œæäº¤ä»£ç ï¼Œæˆ‘å»ºç«‹äº†ç›¸å…³çš„ä»“åº“ï¼šhttps://github.com/SharingSource/LogicStack-LeetCode ã€‚

åœ¨ä»“åº“åœ°å€é‡Œï¼Œä½ å¯ä»¥çœ‹åˆ°ç³»åˆ—æ–‡ç« çš„é¢˜è§£é“¾æ¥ã€ç³»åˆ—æ–‡ç« çš„ç›¸åº”ä»£ç ã€LeetCode åŸé¢˜é“¾æ¥å’Œå…¶ä»–ä¼˜é€‰é¢˜è§£ã€‚

