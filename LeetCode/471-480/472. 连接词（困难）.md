### é¢˜ç›®æè¿°

è¿™æ˜¯ LeetCode ä¸Šçš„ **[472. è¿æ¥è¯](https://leetcode-cn.com/problems/concatenated-words/solution/gong-shui-san-xie-xu-lie-dpzi-fu-chuan-h-p7no/)** ï¼Œéš¾åº¦ä¸º **å›°éš¾**ã€‚

Tag : ã€Œå­—ç¬¦ä¸²å“ˆå¸Œã€ã€ã€Œåºåˆ— DPã€




ç»™ä½ ä¸€ä¸ª ä¸å«é‡å¤ å•è¯çš„å­—ç¬¦ä¸²æ•°ç»„ `words` ï¼Œè¯·ä½ æ‰¾å‡ºå¹¶è¿”å› `words` ä¸­çš„æ‰€æœ‰ è¿æ¥è¯ ã€‚

è¿æ¥è¯ å®šä¹‰ä¸ºï¼šä¸€ä¸ªå®Œå…¨ç”±ç»™å®šæ•°ç»„ä¸­çš„è‡³å°‘ä¸¤ä¸ªè¾ƒçŸ­å•è¯ç»„æˆçš„å­—ç¬¦ä¸²ã€‚

ç¤ºä¾‹ 1ï¼š
```
è¾“å…¥ï¼šwords = ["cat","cats","catsdogcats","dog","dogcatsdog","hippopotamuses","rat","ratcatdogcat"]

è¾“å‡ºï¼š["catsdogcats","dogcatsdog","ratcatdogcat"]

è§£é‡Šï¼š"catsdogcats" ç”± "cats", "dog" å’Œ "cats" ç»„æˆ; 
     "dogcatsdog" ç”± "dog", "cats" å’Œ "dog" ç»„æˆ; 
     "ratcatdogcat" ç”± "rat", "cat", "dog" å’Œ "cat" ç»„æˆã€‚
```
ç¤ºä¾‹ 2ï¼š
```
è¾“å…¥ï¼šwords = ["cat","dog","catdog"]

è¾“å‡ºï¼š["catdog"]
```

æç¤ºï¼š
* $1 <= words.length <= 10^4$
* $0 <= words[i].length <= 1000$
* $words[i]$ ä»…ç”±å°å†™å­—æ¯ç»„æˆ
* $0 <= sum(words[i].length) <= 10^5$

---

### åºåˆ— DP + å­—ç¬¦ä¸²å“ˆå¸Œ

ç»™å®šæ•°ç»„ $words$ï¼Œå…ˆè€ƒè™‘å¦‚ä½•åˆ¤æ–­æŸä¸ª $s = words[i]$ æ˜¯å¦ä¸ºã€Œè¿æ¥è¯ã€ã€‚

ä¸ºäº†æ–¹ä¾¿ï¼Œæˆ‘ä»¬ç§°ç»„æˆ `s` çš„æ¯ä¸ªè¿æ¥éƒ¨åˆ†ä¸º `item`ã€‚

ä¸¾ä¸ª ğŸŒ°ï¼Œä¾‹å¦‚ `s = abc`ï¼Œå…¶å¯èƒ½çš„ `item` ç»„åˆä¸º `a` å’Œ `bc`ã€‚

åˆ¤æ–­å•ä¸ªå­—ç¬¦ä¸²æ˜¯å¦ä¸ºè¿æ¥è¯å¯ä½¿ç”¨åŠ¨æ€è§„åˆ’æ±‚è§£ï¼š**å®šä¹‰ $f[i]$ ä¸ºè€ƒè™‘ `s` çš„å‰ $i$ ä¸ªå­—ç¬¦ï¼ˆä»¤ä¸‹æ ‡ä» $1$ å¼€å§‹ï¼‰ï¼Œèƒ½å¤Ÿåˆ‡åˆ†å‡ºçš„æœ€å¤§ `item` æ•°çš„ä¸ªæ•°ã€‚**

è¿™é‡Œä¹‹æ‰€ä»¥é‡‡ç”¨ã€Œè®°å½• $f[i]$ ä¸ºæœ€å¤§åˆ†å‰² `item` æ•°ï¼ˆ`int` ç±»å‹åŠ¨è§„æ•°ç»„ï¼‰ã€ï¼Œè€Œä¸æ˜¯ã€Œè®°å½• $f[i]$ ä¸ºæ˜¯å¦å¯ç”±å¤šä¸ª `item` ç»„æˆï¼ˆ`bool` ç±»å‹åŠ¨è§„æ•°ç»„ï¼‰ã€ï¼Œæ˜¯å› ä¸ºæ¯ä¸ª $s = words[i]$ è‡³å°‘å¯ç”±è‡ªèº«ç»„æˆï¼Œé‡‡ç”¨ `bool` è®°å½•çŠ¶æ€çš„è¯ï¼Œæœ€ç»ˆ $f[n]$ å¿…ç„¶ä¸º `True`ï¼Œéœ€è¦é¢å¤–å¤„ç†æœ€åä¸€ä¸ªçŠ¶æ€ï¼Œå¹²è„†è®°å½•æœ€å¤§åˆ†å‰²æ•°é‡å¥½äº†ã€‚æ­¤æ—¶å¦‚æœ `s` ä¸ºã€Œè¿æ¥è¯ã€å¿…ç„¶æœ‰ $f[n] > 1$ã€‚

ä¸å¤±ä¸€èˆ¬æ€§çš„è€ƒè™‘ $f[i]$ è¯¥å¦‚ä½•è½¬ç§»ï¼š**å‡è®¾ $f[i]$ å¯ç”± $f[j]$ è½¬ç§»è€Œæ¥ï¼ˆå…¶ä¸­ $j < i$ï¼‰ï¼Œé‚£ä¹ˆèƒ½å¤Ÿè½¬ç§»çš„å……è¦æ¡ä»¶ä¸º $f[j] != 0$ ä¸”å­ä¸² $s[(j + 1)..i]$ åœ¨ $words$ å‡ºç°è¿‡**ã€‚

å…¶ä¸­æšä¸¾ $i$ å’Œ $j$ çš„å¤æ‚åº¦å·²ç»å»åˆ° $O(n^2)$ äº†ï¼Œå¦‚æœå¸¸è§„é€šè¿‡ `HashMap` ç­‰æ•°æ®ç»“æ„åˆ¤æ–­æŸä¸ªå­—ç¬¦ä¸²æ˜¯å¦å­˜åœ¨ï¼Œæ‰§è¡Œå“ˆå¸Œå‡½æ•°æ—¶éœ€è¦å¯¹å­—ç¬¦è¿›è¡Œéå†ï¼Œæ•´ä½“å¤æ‚åº¦å»åˆ°äº† $O(n^3)$ï¼Œä¼š `TLE`ã€‚

**æˆ‘ä»¬é€šè¿‡ã€Œå­—ç¬¦ä¸²å“ˆå¸Œã€æ–¹å¼æ¥ä¼˜åŒ–åˆ¤æ–­æŸä¸ªå­ä¸²æ˜¯å¦å­˜åœ¨äº $words$ ä¸­ã€‚**

å…·ä½“çš„ï¼Œåœ¨åˆ¤æ–­æ¯ä¸ª $s = words[i]$ æ˜¯å¦ä¸ºä¸ºè¿æ¥è¯å‰ï¼Œå…ˆå¯¹ $words$ è¿›è¡Œéå†ï¼Œé¢„å¤„ç†æ¯ä¸ª $words[i]$ çš„å“ˆå¸Œå€¼ï¼Œå¹¶å­˜å…¥ `HashSet` ä¸­ï¼Œè¿™æ ·æˆ‘ä»¬å°†ã€Œåˆ¤æ–­æŸä¸ªå­ä¸²æ˜¯å¦å­˜åœ¨äº $words$ã€çš„é—®é¢˜è½¬åŒ–ä¸ºã€Œåˆ¤æ–­æŸä¸ªæ•°å€¼æ˜¯å¦å­˜åœ¨äº `Set` å½“ä¸­ã€ã€‚

åˆç”±äº **æˆ‘ä»¬åœ¨è®¡ç®—æŸä¸ªå­ä¸² `s` çš„å“ˆå¸Œå€¼æ—¶ï¼Œæ˜¯ä»å‰å¾€åå¤„ç†æ¯ä¸€ä½çš„ $s[i]$ï¼Œå› æ­¤åœ¨è½¬ç§» $f[i]$ æ—¶ï¼Œæˆ‘ä»¬æœŸæœ›èƒ½å¤Ÿä»å‰å¾€åå¤„ç†å­ä¸²ï¼Œè¿™æ˜¯å¸¸è§„çš„ä» $[0, i - 1]$ èŒƒå›´å†…æ‰¾å¯è½¬ç§»ç‚¹ $f[j]$ æ— æ³•åšåˆ°çš„**ã€‚

æ‰€ä»¥ **æˆ‘ä»¬è°ƒæ•´è½¬ç§»é€»è¾‘ä¸ºï¼šä» $f[i]$ å‡ºå‘ï¼Œæšä¸¾èŒƒå›´ $[i + 1, n]$ï¼Œæ‰¾åˆ°å¯ç”± $f[i]$ æ‰€èƒ½æ›´æ–°çš„çŠ¶æ€ $f[j]$ï¼Œå¹¶å°è¯•ä½¿ç”¨ $f[i]$ æ¥æ›´æ–° $f[j]$ã€‚è½¬ç§»æ–¹ç¨‹ä¸ºï¼š**

$$
f[j] = \max(f[j], f[i] + 1)
$$

å½“ç„¶ï¼Œèƒ½å¤Ÿè½¬ç§»çš„å‰ææ¡ä»¶ä¸º $f[i]$ ä¸ºæœ‰æ•ˆå€¼ï¼Œä¸”å­ä¸² $s[(i + 1), j]$ åœ¨ $words$ å‡ºç°è¿‡ã€‚

> ä¸€äº›ç»†èŠ‚ï¼šä¸ºäº†æ–¹ä¾¿ï¼Œæˆ‘ä»¬å®šä¹‰ $f[i] = -1$ ä¸ºæ— æ•ˆçŠ¶æ€ï¼›
å¦å¤–ç”±äºå­—ç¬¦ä¸²å“ˆå¸Œä¼šäº§ç”Ÿå“ˆå¸Œç¢°æ’ï¼Œè¿™é‡Œåœ¨è®¡ç®—å“ˆå¸Œå€¼çš„æ—¶å€™ï¼Œä¿®æ”¹äº†ä¸€ä¸‹å“ˆå¸Œè®¡ç®—æ–¹å¼ï¼ˆé¢å¤–å¢åŠ äº†ä¸€ä¸ª `OFFSET`ï¼‰ï¼Œå½“æ—¶çš„ç›®çš„æ˜¯æƒ³åœ¨ç”µè„‘æ²¡ç”µå‰ `AC`ï¼Œè€Œå¦ä¸€ä¸ªæ›´åŠ ç¨³å¦¥çš„æ–¹å¼æ˜¯ä½¿ç”¨åŒå“ˆå¸Œï¼Œæˆ–æ˜¯å¹²è„†è®°å½•æŸä¸ªå“ˆå¸Œå€¼å¯¹åº”äº†å“ªäº›å­—ç¬¦ä¸²ã€‚

Java ä»£ç ï¼š
```Java
class Solution {
    Set<Long> set = new HashSet<>();
    int P = 131, OFFSET = 128;
    public List<String> findAllConcatenatedWordsInADict(String[] words) {
        for (String s : words) {
            long hash = 0;
            for (char c : s.toCharArray()) hash = hash * P + (c - 'a') + OFFSET;
            set.add(hash);
        }
        List<String> ans = new ArrayList<>();
        for (String s : words) {
            if (check(s)) ans.add(s);
        }
        return ans;
    }
    boolean check(String s) {
        int n = s.length();
        int[] f = new int[n + 1];
        Arrays.fill(f, -1);
        f[0] = 0;
        for (int i = 0; i <= n; i++) {
            if (f[i] == -1) continue;
            long cur = 0;
            for (int j = i + 1; j <= n; j++) {
                cur = cur * P + (s.charAt(j - 1) - 'a') + OFFSET;
                if (set.contains(cur)) f[j] = Math.max(f[j], f[i] + 1);
            }
            if (f[n] > 1) return true;
        }
        return false;
    }
}
```
C++ ä»£ç ï¼š
```C++
class Solution {
public:
    unordered_set<uint64_t> set;
    const uint64_t P = 131;
    const uint64_t OFFSET = 128;
    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {
        for (const string& s : words) {
            uint64_t hash = 0;
            for (char c : s) hash = hash * P + (c - 'a') + OFFSET;
            set.insert(hash);
        }
        vector<string> ans;
        for (const string& s : words) {
            if (check(s)) ans.push_back(s);
        }
        return ans;
    }
    bool check(const string& s) {
        int n = s.size();
        vector<int> f(n + 1, -1);
        f[0] = 0;
        for (int i = 0; i <= n; i++) {
            if (f[i] == -1) continue;
            uint64_t cur = 0;
            for (int j = i + 1; j <= n; j++) {
                cur = cur * P + (s[j - 1] - 'a') + OFFSET;
                if (set.find(cur) != set.end()) {
                    f[j] = max(f[j], f[i] + 1);
                }
            }
            if (f[n] > 1) return true;
        }
        return false;
    }
};
```
Python ä»£ç ï¼š
```Python
class Solution:
    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:
        self.set = set()
        self.P = 131
        self.OFFSET = 128
        for s in words:
            hash_val = 0
            for c in s:
                hash_val = hash_val * self.P + (ord(c) - ord('a')) + self.OFFSET
            self.set.add(hash_val)
        ans = []
        for s in words:
            if self.check(s):
                ans.append(s)
        return ans

    def check(self, s):
        n = len(s)
        f = [-1] * (n + 1)
        f[0] = 0
        for i in range(n + 1):
            if f[i] == -1:
                continue
            cur = 0
            for j in range(i + 1, n + 1):
                cur = cur * self.P + (ord(s[j - 1]) - ord('a')) + self.OFFSET
                if cur in self.set:
                    if f[j] == -1:
                        f[j] = f[i] + 1
                    else:
                        f[j] = max(f[j], f[i] + 1)
            if f[n] > 1:
                return True
        return False
```
* æ—¶é—´å¤æ‚åº¦ï¼šä»¤ $n$ ä¸º $words$ æ•°ç»„é•¿åº¦ï¼Œ$N = \sum_{i = 0}^{n - 1}words[i].length$ï¼Œæ ¹æ®æ•°æ®èŒƒå›´ $N$ æœ€å¤§ä¸º $1e5$ã€‚é¢„å¤„ç†å‡º `Set` çš„å¤æ‚åº¦ä¸º $O(N)$ï¼›ä¼šå¯¹æ‰€æœ‰ $words[i]$ æ‰§è¡Œ `check` æ“ä½œï¼Œå¤æ‚åº¦ä¸º $O((words[i].length)^2)$ï¼Œæ€»çš„è®¡ç®—é‡æœ€å¤§å€¼ä¸º $O(N^2)$ï¼Œç”±äºå­˜åœ¨å‰ªæï¼Œå®é™…ä¸Šè¾¾ä¸åˆ°è¯¥è®¡ç®—é‡
* ç©ºé—´å¤æ‚åº¦ï¼š$O(n + \max(words[i].length))$

---

### æœ€å

è¿™æ˜¯æˆ‘ä»¬ã€Œåˆ·ç©¿ LeetCodeã€ç³»åˆ—æ–‡ç« çš„ç¬¬ `No.472` ç¯‡ï¼Œç³»åˆ—å¼€å§‹äº 2021/01/01ï¼Œæˆªæ­¢äºèµ·å§‹æ—¥ LeetCode ä¸Šå…±æœ‰ 1916 é“é¢˜ç›®ï¼Œéƒ¨åˆ†æ˜¯æœ‰é”é¢˜ï¼Œæˆ‘ä»¬å°†å…ˆæŠŠæ‰€æœ‰ä¸å¸¦é”çš„é¢˜ç›®åˆ·å®Œã€‚

åœ¨è¿™ä¸ªç³»åˆ—æ–‡ç« é‡Œé¢ï¼Œé™¤äº†è®²è§£è§£é¢˜æ€è·¯ä»¥å¤–ï¼Œè¿˜ä¼šå°½å¯èƒ½ç»™å‡ºæœ€ä¸ºç®€æ´çš„ä»£ç ã€‚å¦‚æœæ¶‰åŠé€šè§£è¿˜ä¼šç›¸åº”çš„ä»£ç æ¨¡æ¿ã€‚

ä¸ºäº†æ–¹ä¾¿å„ä½åŒå­¦èƒ½å¤Ÿç”µè„‘ä¸Šè¿›è¡Œè°ƒè¯•å’Œæäº¤ä»£ç ï¼Œæˆ‘å»ºç«‹äº†ç›¸å…³çš„ä»“åº“ï¼šhttps://github.com/SharingSource/LogicStack-LeetCode ã€‚

åœ¨ä»“åº“åœ°å€é‡Œï¼Œä½ å¯ä»¥çœ‹åˆ°ç³»åˆ—æ–‡ç« çš„é¢˜è§£é“¾æ¥ã€ç³»åˆ—æ–‡ç« çš„ç›¸åº”ä»£ç ã€LeetCode åŸé¢˜é“¾æ¥å’Œå…¶ä»–ä¼˜é€‰é¢˜è§£ã€‚
