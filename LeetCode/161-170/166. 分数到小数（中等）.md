### 题目描述

这是 LeetCode 上的 **[166. 分数到小数](https://leetcode-cn.com/problems/fraction-to-recurring-decimal/solution/gong-shui-san-xie-mo-ni-shu-shi-ji-suan-kq8c4/)** ，难度为 **中等**。

Tag : 「数学」、「模拟」、「哈希表」



给定两个整数，分别表示分数的分子 `numerator` 和分母 `denominator`，以字符串形式返回小数。

如果小数部分为循环小数，则将循环的部分括在括号内。

如果存在多个答案，只需返回任意一个。

对于所有给定的输入，保证答案字符串的长度小于 $10^4$ 。

示例 1：
```
输入：numerator = 1, denominator = 2

输出："0.5"
```
示例 2：
```
输入：numerator = 2, denominator = 1

输出："2"
```
示例 3：
```
输入：numerator = 2, denominator = 3

输出："0.(6)"
```
示例 4：
```
输入：numerator = 4, denominator = 333

输出："0.(012)"
```
示例 5：
```
输入：numerator = 1, denominator = 5

输出："0.2"
```

提示：
* $-2^{31} <= numerator, denominator <= 2^{31} - 1$
* `denominator != 0`

---

### 模拟

这是一道模拟 [竖式计算（除法）](https://baike.baidu.com/item/%E7%AB%96%E5%BC%8F%E8%AE%A1%E7%AE%97)的题目。

首先可以明确，两个数相除要么是「有限位小数」，要么是「无限循环小数」，而不可能是「无限不循环小数」。

然后考虑人工计算两数相除是如何进行：

![](https://pic.leetcode-cn.com/1633223480-OLGSxy-file_1633223479713)

这引导我们可以在模拟竖式计算（除法）过程中，使用「哈希表」记录某个余数最早在什么位置出现过，一旦出现相同余数，则将「出现位置」到「当前结尾」之间的字符串抠出来，即是「循环小数」部分。

> PS. 到这里，从人工模拟除法运算的过程，我们就可以知道「为什么不会出现“无限不循环小数”」，因为始终是对余数进行补零操作，再往下进行运算，而余数个数具有明确的上限（有限集）。所以一直往下计算，最终结果要么是「出现相同余数」，要么是「余数为 $0$，运算结束」。

一些细节：

* 一个显然的条件是，如果本身两数能够整除，直接返回即可；
* 如果两个数有一个为“负数”，则最终答案为“负数”，因此可以起始先判断两数相乘是否小于 $0$，如果是，先往答案头部追加一个负号 `-`；
* 两者范围为 `int`，但计算结果可以会超过 `int` 范围，考虑 $numerator = -2^{31}$ 和 $denominator = -1$ 的情况，其结果为 $2^{31}$，超出 `int` 的范围 $[-2^{31}, 2^{31} - 1]$。因此起始需要先使用 `long` 对两个入参类型转换一下。

Java 代码：
```Java
class Solution {
    public String fractionToDecimal(int numerator, int denominator) {
        // 转 long 计算，防止溢出
        long a = numerator, b = denominator;
        // 如果本身能够整除，直接返回计算结果
        if (a % b == 0) return String.valueOf(a / b);
        StringBuilder sb = new StringBuilder();
        // 如果其一为负数，先追加负号
        if (a * b < 0) sb.append('-');
        a = Math.abs(a); b = Math.abs(b);
        // 计算小数点前的部分，并将余数赋值给 a
        sb.append(String.valueOf(a / b) + ".");
        a %= b;
        Map<Long, Integer> map = new HashMap<>();
        while (a != 0) {
            // 记录当前余数所在答案的位置，并继续模拟除法运算
            map.put(a, sb.length());
            a *= 10;
            sb.append(a / b);
            a %= b;
            // 如果当前余数之前出现过，则将 [出现位置 到 当前位置] 的部分抠出来（循环小数部分）
            if (map.containsKey(a)) {
                int u = map.get(a);
                return String.format("%s(%s)", sb.substring(0, u), sb.substring(u));
            }
        }
        return sb.toString();
    }
}
```
C++ 代码：
```C++
class Solution {
public:
    string fractionToDecimal(int numerator, int denominator) {
        long long a = numerator, b = denominator;
        if (a % b == 0) return to_string(a / b);
        string ans;
        if (a * b < 0) ans += '-';
        a = abs(a); b = abs(b);
        ans += to_string(a / b) + ".";
        a %= b;
        unordered_map<long long, int> rem_pos;
        while (a != 0) {
            rem_pos[a] = ans.size();
            a *= 10;
            ans += to_string(a / b);
            a %= b;
            if (rem_pos.find(a) != rem_pos.end()) {
                int pos = rem_pos[a];
                return ans.substr(0, pos) + "(" + ans.substr(pos) + ")";
            }
        }
        return ans; 
    }
};
```
Python 代码：
```Python
class Solution:
    def fractionToDecimal(self, numerator: int, denominator: int) -> str:
        a, b = numerator, denominator
        if a % b == 0:
            return str(a // b)
        ans = []
        if a * b < 0:
            ans.append('-')
        a, b = abs(a), abs(b)
        ans.append(str(a // b))
        ans.append('.')
        a %= b
        rem_pos = {}
        while a != 0:
            if a in rem_pos:
                pos = rem_pos[a]
                return ''.join(ans[:pos]) + '(' + ''.join(ans[pos:]) + ')'
            rem_pos[a] = len(ans)
            a *= 10
            ans.append(str(a // b))
            a %= b
        return ''.join(ans)
```
TypeScript 代码：
```TypeScript
function fractionToDecimal(numerator: number, denominator: number): string {
    let a = numerator, b = denominator;
    if (a % b === 0) return (a / b).toString();
    let ans = [];
    if (a * b < 0) ans.push('-')
    a = Math.abs(a); b = Math.abs(b);
    ans.push(Math.floor(a / b).toString());
    ans.push('.');
    a %= b;
    const map = new Map();
    while (a !== 0) {
        map.set(a, ans.length);
        a *= 10;
        ans.push(Math.floor(a / b).toString());
        a %= b;
        if (map.has(a)) {
            const pos = map.get(a)!;
            return ans.slice(0, pos).join('') + '(' + ans.slice(pos).join('') + ')';
        }
    }
    return ans.join('');
};
```
* 时间复杂度：复杂度取决于最终答案的长度，题目规定了最大长度不会超过 $10^4$，整体复杂度为 $O(M)$
* 空间复杂度：复杂度取决于最终答案的长度，题目规定了最大长度不会超过 $10^4$，整体复杂度为 $O(M)$

---

### 最后

这是我们「刷穿 LeetCode」系列文章的第 `No.166` 篇，系列开始于 2021/01/01，截止于起始日 LeetCode 上共有 1916 道题目，部分是有锁题，我们将先把所有不带锁的题目刷完。

在这个系列文章里面，除了讲解解题思路以外，还会尽可能给出最为简洁的代码。如果涉及通解还会相应的代码模板。

为了方便各位同学能够电脑上进行调试和提交代码，我建立了相关的仓库：https://github.com/SharingSource/LogicStack-LeetCode

在仓库地址里，你可以看到系列文章的题解链接、系列文章的相应代码、LeetCode 原题链接和其他优选题解。

