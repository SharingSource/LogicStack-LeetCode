### é¢˜ç›®æè¿°

è¿™æ˜¯ LeetCode ä¸Šçš„ **[747. è‡³å°‘æ˜¯å…¶ä»–æ•°å­—ä¸¤å€çš„æœ€å¤§æ•°](https://leetcode-cn.com/problems/largest-number-at-least-twice-of-others/solution/gong-shui-san-xie-jian-dan-mo-ni-ti-by-a-8179/)** ï¼Œéš¾åº¦ä¸º **ç®€å•**ã€‚

Tag : ã€Œæ¨¡æ‹Ÿã€



ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ $nums$ ï¼Œå…¶ä¸­æ€»æ˜¯å­˜åœ¨ **å”¯ä¸€çš„** ä¸€ä¸ªæœ€å¤§æ•´æ•° ã€‚

è¯·ä½ æ‰¾å‡ºæ•°ç»„ä¸­çš„æœ€å¤§å…ƒç´ å¹¶æ£€æŸ¥å®ƒæ˜¯å¦ è‡³å°‘æ˜¯æ•°ç»„ä¸­æ¯ä¸ªå…¶ä»–æ•°å­—çš„ä¸¤å€ ã€‚

å¦‚æœæ˜¯ï¼Œåˆ™è¿”å› **æœ€å¤§å…ƒç´ çš„ä¸‹æ ‡** ï¼Œå¦åˆ™è¿”å› $-1$ ã€‚

ç¤ºä¾‹ 1ï¼š
```
è¾“å…¥ï¼šnums = [3,6,1,0]

è¾“å‡ºï¼š1

è§£é‡Šï¼š6 æ˜¯æœ€å¤§çš„æ•´æ•°ï¼Œå¯¹äºæ•°ç»„ä¸­çš„å…¶ä»–æ•´æ•°ï¼Œ6 å¤§äºæ•°ç»„ä¸­å…¶ä»–å…ƒç´ çš„ä¸¤å€ã€‚6 çš„ä¸‹æ ‡æ˜¯ 1 ï¼Œæ‰€ä»¥è¿”å› 1 ã€‚
```

ç¤ºä¾‹ 2ï¼š
```
è¾“å…¥ï¼šnums = [1,2,3,4]
è¾“å‡ºï¼š-1
è§£é‡Šï¼š4 æ²¡æœ‰è¶…è¿‡ 3 çš„ä¸¤å€å¤§ï¼Œæ‰€ä»¥è¿”å› -1 ã€‚
```
ç¤ºä¾‹ 3ï¼š
```
è¾“å…¥ï¼šnums = [1]

è¾“å‡ºï¼š0

è§£é‡Šï¼šå› ä¸ºä¸å­˜åœ¨å…¶ä»–æ•°å­—ï¼Œæ‰€ä»¥è®¤ä¸ºç°æœ‰æ•°å­— 1 è‡³å°‘æ˜¯å…¶ä»–æ•°å­—çš„ä¸¤å€ã€‚
```

æç¤ºï¼š
* $1 <= nums.length <= 50$
* $0 <= nums[i] <= 100$
* $nums$ ä¸­çš„æœ€å¤§å…ƒç´ æ˜¯å”¯ä¸€çš„

---

### æ¨¡æ‹Ÿ

æ ¹æ®é¢˜æ„è¿›è¡Œæ¨¡æ‹Ÿå³å¯ï¼Œéå†è¿‡ç¨‹ä¸­ç»´æŠ¤æœ€å¤§å€¼å’Œæ¬¡å¤§å€¼çš„ä¸‹æ ‡ï¼Œæœ€ååˆ¤æ–­æœ€å¤§å€¼æ˜¯å¦è‡³å°‘ä¸ºæ¬¡å¤§å€¼ä¸¤å€ã€‚

ç„¶åï¼Ÿä»Šå¤©å±äºåœ†æ¢¦äº†ï¼Ÿï¼ˆè¿™çœŸçš„åªæ˜¯ä»–ä»¬çš„æ—¥å¸¸å¯çˆ± ğŸ¤£

![image.png](https://pic.leetcode-cn.com/1642041486-TCwCib-image.png)

**ä»£ç ï¼ˆæ„Ÿè°¢ [@5cm/s ğŸŒ¸](/u/megurine/)ã€[@Benhao](/u/himymben/) å’Œ [@Qian](/u/qian2/) å‡ ä½æ€»æä¾›çš„å…¶ä»–è¯­è¨€ç‰ˆæœ¬ ğŸ¤£ ğŸ¤£ ï¼‰ï¼š**
```Java
class Solution {
    public int dominantIndex(int[] nums) {
        int n = nums.length;
        if (n == 1) return 0;
        int a = -1, b = 0;
        for (int i = 1; i < n; i++) {
            if (nums[i] > nums[b]) {
                a = b; b = i;
            } else if (a == -1 || nums[i] > nums[a]) {
                a = i;
            }
        }
        return nums[b] >= nums[a] * 2 ? b : -1;
    }
}
```
-
```Python
class Solution(object):
    def dominantIndex(self, nums):
        n = len(nums)
        if n == 1:
            return 0
        a, b = -1, 0
        for i in range(1, n):
            if nums[i] > nums[b]:
                a, b = b, i
            elif a == -1 or nums[i] > nums[a]:
                a = i
        return b if nums[b] >= nums[a] * 2 else -1
```
-
```Python
class Solution:
    def dominantIndex(self, nums: List[int]) -> int:
        n = len(nums)
        if n == 1:
            return 0
        a, b = -1, 0
        for i in range(1, n):
            if nums[i] > nums[b]:
                a, b = b, i
            elif a == -1 or nums[i] > nums[a]:
                a = i
        return b if nums[b] >= nums[a] * 2 else -1
```
-
```Go
func dominantIndex(nums []int) int {
    n := len(nums)
    if n == 1{
        return 0
    }
    a, b := -1, 0
    for i := 1; i < n; i++ {
        if nums[i] > nums[b] {
            a, b = b, i
        } else if a == -1 || nums[i] > nums[a] {
            a = i
        }
    }
    if nums[b] >= nums[a] * 2{
        return b
    }
    return -1
}
```
-
```Rust
impl Solution {
    pub fn dominant_index(nums: Vec<i32>) -> i32 {
        let mut mx = 0;
        let mut ans = -1 as i32;
        for i in 0..nums.len() {
            if nums[i] >= mx * 2 {
                ans = i as i32;
            }
            else if nums[i] * 2 > mx {
                ans = -1 as i32;
            }
            if nums[i] > mx {
                mx = nums[i];
            }
        }
        ans
    }
}
```
-
```C
int dominantIndex(int* nums, int numsSize){
    if(numsSize == 1) return 0;
    int a = -1, b = 0;
    for(int i = 1; i < numsSize; i++){
        if (nums[i] > nums[b]) {
            a = b; b = i;
        } else if (a == -1 || nums[i] > nums[a]) {
            a = i;
        }
    }
    return nums[b] >= nums[a] * 2 ? b : -1;
}
```
-
```C#
public class Solution {
    public int DominantIndex(int[] nums) {
        int n = nums.Length;
        if (n == 1) return 0;
        int a = -1, b = 0;
        for (int i = 1; i < n; i++) {
            if (nums[i] > nums[b]) {
                a = b; b = i;
            } else if (a == -1 || nums[i] > nums[a]) {
                a = i;
            }
        }
        return nums[b] >= nums[a] * 2 ? b : -1;
    }
}
```
-
```C++
class Solution {
public:
    int dominantIndex(vector<int>& nums) {
        int mx = 0, ans = -1;
        for (int i = 0; i < nums.size(); ++i) {
            if (nums[i] >= mx * 2) ans = i;
            else if (nums[i] * 2 > mx) ans = -1;
            mx = max(nums[i], mx);
        }
        return ans;
    }
};
```
-
```JS
var dominantIndex = function(nums) {
    const n = nums.length
    if(n == 1) return 0
    let a = -1, b = 0
    for (let i = 1; i < n; i++){
        if (nums[i] > nums[b]) {
            a = b; b = i;
        } else if (a == -1 || nums[i] > nums[a]) {
            a = i;
        }
    }
    return nums[b] >= nums[a] * 2 ? b : -1;
};
```
-
```TS
function dominantIndex(nums: number[]): number {
    const n = nums.length
    if(n == 1) return 0
    let a = -1, b = 0
    for (let i = 1; i < n; i++){
        if (nums[i] > nums[b]) {
            a = b; b = i;
        } else if (a == -1 || nums[i] > nums[a]) {
            a = i;
        }
    }
    return nums[b] >= nums[a] * 2 ? b : -1;
};
```
-
```PHP
class Solution {
    function dominantIndex($nums) {
        $n = sizeof($nums);
        if ($n == 1) return 0;
        $a = -1; $b = 0;
        for ($i = 1; $i < $n; $i++) {
            if ($nums[$i] > $nums[$b]) {
                $a = $b;
                $b = $i;
            } else if ($a == -1 || $nums[$i] > $nums[$a]) {
                $a = $i;
            }
        }
        if($nums[$b] >= $nums[$a] * 2){
            return $b;
        }
        return -1;
    }
}
```
-
```Swift
class Solution {
    func dominantIndex(_ nums: [Int]) -> Int {
        var n = nums.count
        if n == 1 {
            return 0
        }
        var (a, b) = (-1, 0)
        for i in 1..<nums.count {
            if nums[i] > nums[b] {
                (a, b) = (b, i)
            }
            else if a == -1 || nums[i] > nums[a] {
                a = i
            }
        }
        return nums[b] >= nums[a] * 2 ? b : -1
    }
}
```
-
```Kotlin
class Solution {
    fun dominantIndex(nums: IntArray): Int {
        var mx = 0
        var ans = -1
        for (i in nums.indices) {
            when {
                nums[i] >= mx * 2 -> ans = i
                nums[i] * 2 > mx -> ans = -1
            }
            if (nums[i] > mx) mx = nums[i]
        }
        return ans
    }
}
```
-
```Scala
object Solution {
    def dominantIndex(nums: Array[Int]): Int = {
        var mx = 0
        var ans = -1
        for (i <- 0 to (nums.length - 1)) {
            if (nums(i) >= mx * 2) ans = i
            else if (nums(i) * 2 > mx) ans = -1
            if (nums(i) > mx) mx = nums(i)
        }
        return ans
    }
}
```
-
```Ruby
def dominant_index(nums)
    n = nums.length
    return 0 if n == 1
    a = -1
    b = 0
    nums.each_with_index do |num, i|
        next if i == 0
        if nums[i] > nums[b]
            a = b
            b = i
        elsif a.eql?(-1) or nums[i] > nums[a]
            a = i
        end
    end
    return nums[b] >= nums[a] * 2 ? b : -1
end
```
-
```lisp
(define/contract (dominant-index nums)
  (-> (listof exact-integer?) exact-integer?)
  (let loop ([nums nums] [i 0] [mx 0] [ans -1])
    (cond
      [(empty? nums) ans]
      [else
        (define x (car nums))
        (define mxx (max x mx))
        (cond
          [(>= x (* mx 2)) (loop (cdr nums) (+ i 1) mxx i)]
          [(> (* x 2) mx) (loop (cdr nums) (+ i 1) mxx -1)]
          [else (loop (cdr nums) (+ i 1) mxx ans)]
        )
      ]
    )
  )
)
```
-

```Elixir
defmodule Solution do
  @spec dominant_index(nums :: [integer]) :: integer
  def dominant_index(nums) do
    solve(nums, 0, -1, 0)
  end
  def solve([], mx, ans, cur) do
    ans
  end
  def solve([x | rest], mx, ans, cur) when x >= mx * 2 do
    solve(rest, max(x, mx), cur, cur + 1)
  end
  def solve([x | rest], mx, ans, cur) when x * 2 > mx do
    solve(rest, max(x, mx), -1, cur + 1)
  end
  def solve([x | rest], mx, ans, cur) do
    solve(rest, max(x, mx), ans, cur + 1)
  end
end
```
-
```Erlang
-spec dominant_index(Nums :: [integer()]) -> integer().
dominant_index(Nums) ->
  solve(Nums).

solve(List) ->
  solve(List, 0, -1, 0).
solve([], Max, Ans, Cur) ->
  Ans;
solve([Head|Rest], Max, Ans, Cur) when Head >= Max * 2 ->
  solve(Rest, max(Max, Head), Cur, Cur + 1);
solve([Head|Rest], Max, Ans, Cur) when Head * 2 > Max ->
  solve(Rest, max(Max, Head), -1, Cur + 1);
solve([Head|Rest], Max, Ans, Cur) ->
  solve(Rest, max(Max, Head), Ans, Cur + 1).

max(A, B) when A > B ->
  A;
max(A, B) ->
  B.
```
* æ—¶é—´å¤æ‚åº¦ï¼š$O(n)$
* ç©ºé—´å¤æ‚åº¦ï¼š$O(1)$

---

### å…¨é±¼å®´ï¼ˆæ˜¯å…¨è¯­è¨€ è¿™é”™åˆ«å­—è¿˜æŒºå¯çˆ± ğŸ¤£

ç»è¿‡ä¸‰ä½æ€» [@5cm/s ğŸŒ¸](/u/megurine/)ã€[@Benhao](/u/himymben/) å’Œ [@Qian](/u/qian2/) çš„ä¸æ‡ˆåŠªåŠ›ï¼Œé€šè¿‡ä¸¾ä¸€åä¸‰ã€è¿è’™å¸¦çŒœï¼ŒæŠŠæ‰€æœ‰è¯­è¨€å¼„å‡ºäº† ğŸ¤£

è¿™ä¸ªè¿‡ç¨‹ä¸­ä¹Ÿæœ‰å¹¸è§åˆ°ï¼Œå¦‚æœä¸€ä¸ªè¯­è¨€åªæœ‰ä¸€ä»½ä»£ç ï¼Œå±…ç„¶ç•Œé¢æ˜¯è¿™æ ·çš„ï¼ˆæ²¡æœ‰æ—¶é—´å’Œå†…å­˜çš„åˆ†å¸ƒå›¾ï¼š

![image.png](https://pic.leetcode-cn.com/1642054606-AiJDCs-image.png)

æˆ‘å’Œæˆ‘çš„å°ä¼™ä¼´çº·çº·è¡¨ç¤ºè¿™æ ·çš„ Flag å†ä¹Ÿä¸æ•¢äº† ğŸ¤£

---

### æœ€å

è¿™æ˜¯æˆ‘ä»¬ã€Œåˆ·ç©¿ LeetCodeã€ç³»åˆ—æ–‡ç« çš„ç¬¬ `No.747` ç¯‡ï¼Œç³»åˆ—å¼€å§‹äº 2021/01/01ï¼Œæˆªæ­¢äºèµ·å§‹æ—¥ LeetCode ä¸Šå…±æœ‰ 1916 é“é¢˜ç›®ï¼Œéƒ¨åˆ†æ˜¯æœ‰é”é¢˜ï¼Œæˆ‘ä»¬å°†å…ˆæŠŠæ‰€æœ‰ä¸å¸¦é”çš„é¢˜ç›®åˆ·å®Œã€‚

åœ¨è¿™ä¸ªç³»åˆ—æ–‡ç« é‡Œé¢ï¼Œé™¤äº†è®²è§£è§£é¢˜æ€è·¯ä»¥å¤–ï¼Œè¿˜ä¼šå°½å¯èƒ½ç»™å‡ºæœ€ä¸ºç®€æ´çš„ä»£ç ã€‚å¦‚æœæ¶‰åŠé€šè§£è¿˜ä¼šç›¸åº”çš„ä»£ç æ¨¡æ¿ã€‚

ä¸ºäº†æ–¹ä¾¿å„ä½åŒå­¦èƒ½å¤Ÿç”µè„‘ä¸Šè¿›è¡Œè°ƒè¯•å’Œæäº¤ä»£ç ï¼Œæˆ‘å»ºç«‹äº†ç›¸å…³çš„ä»“åº“ï¼šhttps://github.com/SharingSource/LogicStack-LeetCode ã€‚

åœ¨ä»“åº“åœ°å€é‡Œï¼Œä½ å¯ä»¥çœ‹åˆ°ç³»åˆ—æ–‡ç« çš„é¢˜è§£é“¾æ¥ã€ç³»åˆ—æ–‡ç« çš„ç›¸åº”ä»£ç ã€LeetCode åŸé¢˜é“¾æ¥å’Œå…¶ä»–ä¼˜é€‰é¢˜è§£ã€‚

