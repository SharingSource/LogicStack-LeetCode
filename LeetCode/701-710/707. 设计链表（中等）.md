### é¢˜ç›®æè¿°

è¿™æ˜¯ LeetCode ä¸Šçš„ **[707. è®¾è®¡é“¾è¡¨](https://leetcode.cn/problems/design-linked-list/solution/by-ac_oier-vaib/)** ï¼Œéš¾åº¦ä¸º **ä¸­ç­‰**ã€‚

Tag : ã€Œé“¾è¡¨ã€



è®¾è®¡é“¾è¡¨çš„å®žçŽ°ã€‚æ‚¨å¯ä»¥é€‰æ‹©ä½¿ç”¨å•é“¾è¡¨æˆ–åŒé“¾è¡¨ã€‚

å•é“¾è¡¨ä¸­çš„èŠ‚ç‚¹åº”è¯¥å…·æœ‰ä¸¤ä¸ªå±žæ€§ï¼š`val`Â å’ŒÂ `next`ã€‚`val`Â æ˜¯å½“å‰èŠ‚ç‚¹çš„å€¼ï¼Œ`next`Â æ˜¯æŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆ/å¼•ç”¨ã€‚

å¦‚æžœè¦ä½¿ç”¨åŒå‘é“¾è¡¨ï¼Œåˆ™è¿˜éœ€è¦ä¸€ä¸ªå±žæ€§Â `prev`Â ä»¥æŒ‡ç¤ºé“¾è¡¨ä¸­çš„ä¸Šä¸€ä¸ªèŠ‚ç‚¹ã€‚å‡è®¾é“¾è¡¨ä¸­çš„æ‰€æœ‰èŠ‚ç‚¹éƒ½æ˜¯ `0-index` çš„ã€‚

åœ¨é“¾è¡¨ç±»ä¸­å®žçŽ°è¿™äº›åŠŸèƒ½ï¼š

* `get(index)`ï¼šèŽ·å–é“¾è¡¨ä¸­ç¬¬Â `index`Â ä¸ªèŠ‚ç‚¹çš„å€¼ã€‚å¦‚æžœç´¢å¼•æ— æ•ˆï¼Œåˆ™è¿”å›ž`-1`ã€‚
* `addAtHead(val)`ï¼šåœ¨é“¾è¡¨çš„ç¬¬ä¸€ä¸ªå…ƒç´ ä¹‹å‰æ·»åŠ ä¸€ä¸ªå€¼ä¸ºÂ `val`Â çš„èŠ‚ç‚¹ã€‚æ’å…¥åŽï¼Œæ–°èŠ‚ç‚¹å°†æˆä¸ºé“¾è¡¨çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ã€‚
* `addAtTail(val)`ï¼šå°†å€¼ä¸ºÂ `val` çš„èŠ‚ç‚¹è¿½åŠ åˆ°é“¾è¡¨çš„æœ€åŽä¸€ä¸ªå…ƒç´ ã€‚
* `addAtIndex(index,val)`ï¼šåœ¨é“¾è¡¨ä¸­çš„ç¬¬Â `index`Â ä¸ªèŠ‚ç‚¹ä¹‹å‰æ·»åŠ å€¼ä¸ºÂ `val`Â  çš„èŠ‚ç‚¹ã€‚å¦‚æžœÂ `index`Â ç­‰äºŽé“¾è¡¨çš„é•¿åº¦ï¼Œåˆ™è¯¥èŠ‚ç‚¹å°†é™„åŠ åˆ°é“¾è¡¨çš„æœ«å°¾ã€‚å¦‚æžœ `index` å¤§äºŽé“¾è¡¨é•¿åº¦ï¼Œåˆ™ä¸ä¼šæ’å…¥èŠ‚ç‚¹ã€‚å¦‚æžœ `index` å°äºŽ `0`ï¼Œåˆ™åœ¨å¤´éƒ¨æ’å…¥èŠ‚ç‚¹ã€‚
* `deleteAtIndex(index)`ï¼šå¦‚æžœç´¢å¼•Â `index` æœ‰æ•ˆï¼Œåˆ™åˆ é™¤é“¾è¡¨ä¸­çš„ç¬¬Â `index` ä¸ªèŠ‚ç‚¹ã€‚

ç¤ºä¾‹ï¼š
```
MyLinkedList linkedList = new MyLinkedList();
linkedList.addAtHead(1);
linkedList.addAtTail(3);
linkedList.addAtIndex(1,2);   //é“¾è¡¨å˜ä¸º1-> 2-> 3
linkedList.get(1);            //è¿”å›ž2
linkedList.deleteAtIndex(1);  //çŽ°åœ¨é“¾è¡¨æ˜¯1-> 3
linkedList.get(1);            //è¿”å›ž3
```

æç¤ºï¼š
* æ‰€æœ‰ `val` å€¼éƒ½åœ¨Â $[1, 1000]$Â ä¹‹å†…ã€‚
* æ“ä½œæ¬¡æ•°å°†åœ¨Â Â $[1, 1000]$Â ä¹‹å†…ã€‚
* è¯·ä¸è¦ä½¿ç”¨å†…ç½®çš„ `LinkedList` åº“ã€‚

---

### åŒå‘é“¾è¡¨

ä¸€é“æ‰‹å†™é“¾è¡¨è£¸é¢˜ï¼ˆå•Šå˜¿ï¼Œ$9$ æœˆæ´»åŠ¨çš„åŒå­¦è¡¨ç¤ºå¾ˆæ£’ ðŸ¤£

ç”±äºŽéœ€è¦æ¶‰åŠéƒ¨åˆ† `index` ç›¸å…³æ“ä½œï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥å®žçŽ°ä¸€ä¸ªã€ŒåŒå‘é“¾è¡¨ã€ï¼ŒåŒæ—¶ä½¿ç”¨å˜é‡ `sz` è®°å½•ä¸‹å½“å‰é“¾è¡¨çš„æ€»é•¿åº¦ï¼Œè¿™æ ·åœ¨æ¶‰åŠ `index` æ“ä½œæ—¶ï¼Œå¯ä»Žè¾ƒè¿‘çš„ä¸€è¾¹å‡ºå‘éåŽ†ï¼Œå‰©ä¸‹çš„åˆ™æ˜¯å¸¸è§„çš„é“¾è¡¨èŠ‚ç‚¹æ“ä½œã€‚

> ä¸€äº›ç»†èŠ‚ï¼šæ‰€æœ‰çš„é“¾è¡¨é¢˜ç›®æˆ‘ä»¬éƒ½å¯ä»¥å¼•å…¥å‰åŽå“¨å…µæ¥ç®€åŒ–è¾¹ç•Œå¤„ç†ï¼›åŒæ—¶èƒ½å†™åŒé“¾è¡¨è‡ªç„¶èƒ½å†™å•é“¾è¡¨ï¼Œå› æ­¤å¦‚æžœä½ æ²¡æœ‰é¡ºåˆ©å†™å‡ºåŒé“¾è¡¨çš„è¯ï¼Œåœ¨çœ‹äº†é¢˜è§£å†™å®ŒåŒé“¾è¡¨åŽï¼Œå†æ‰‹å†™ä¸€éå•é“¾è¡¨ä½œä¸ºç»ƒä¹ ã€‚


Java ä»£ç ï¼š
```Java
class MyLinkedList {
    class Node {
        Node prev, next;
        int val;
        Node (int _val) {
            val = _val;
        }
    }
    Node he = new Node(-1), ta = new Node(-1);
    int sz = 0;
    public MyLinkedList() {
        he.next = ta; ta.prev = he;
    }
    public int get(int index) {
        Node node = getNode(index);
        return node == null ? -1 : node.val;
    }
    public void addAtHead(int val) {
        Node node = new Node(val);        
        node.next = he.next; node.prev = he;
        he.next.prev = node; he.next = node;
        sz++;
    }
    public void addAtTail(int val) {
        Node node = new Node(val);
        node.prev = ta.prev; node.next = ta;
        ta.prev.next = node; ta.prev = node;
        sz++;
    }
    public void addAtIndex(int index, int val) {
        if (index > sz) return ;
        if (index <= 0) {
            addAtHead(val); 
        } else if (index == sz) {
            addAtTail(val);
        } else {
            Node node = new Node(val), cur = getNode(index);
            node.next = cur; node.prev = cur.prev;
            cur.prev.next = node; cur.prev = node;
            sz++;
        }
    }
    public void deleteAtIndex(int index) {
        Node cur = getNode(index);
        if (cur == null) return ;
        cur.next.prev = cur.prev;
        cur.prev.next = cur.next;
        sz--;
    }
    Node getNode(int index) {
        boolean isLeft = index < sz / 2;
        if (!isLeft) index = sz - index - 1;
        for (Node cur = isLeft ? he.next : ta.prev; cur != ta && cur != he; cur = isLeft ? cur.next : cur.prev) {
            if (index-- == 0) return cur;
        }
        return null;
    }
}
```
TypeScript ä»£ç ï¼š
```TypeScript
class TNode {
    prev: TNode
    next: TNode
    val: number
    constructor(_val: number) {
        this.val = _val
    }
}
class MyLinkedList {
    he = new TNode(-1)
    ta = new TNode(-1)
    sz = 0
    constructor() {
        this.he.next = this.ta; this.ta.prev = this.he    
    }
    get(index: number): number {
        const node = this.getNode(index)
        return node == null ? -1 : node.val
    }
    addAtHead(val: number): void {
        const node = new TNode(val)
        node.next = this.he.next; node.prev = this.he
        this.he.next.prev = node; this.he.next = node
        this.sz++
    }
    addAtTail(val: number): void {
        const node = new TNode(val)
        node.prev = this.ta.prev; node.next = this.ta
        this.ta.prev.next = node; this.ta.prev = node
        this.sz++
    }
    addAtIndex(index: number, val: number): void {
        if (index > this.sz) return 
        if (index <= 0) {
            this.addAtHead(val)
        } else if (index == this.sz) {
            this.addAtTail(val)
        } else {
            const node = new TNode(val), cur = this.getNode(index)
            node.next = cur; node.prev = cur.prev
            cur.prev.next = node; cur.prev = node
            this.sz++
        }
    }
    deleteAtIndex(index: number): void {
        const cur = this.getNode(index)
        if (cur == null) return 
        cur.prev.next = cur.next
        cur.next.prev = cur.prev
        this.sz--
    }
    getNode(index: number): TNode | null {
        const isLeft = index < this.sz / 2
        if (!isLeft) index = this.sz - index - 1
        for (let cur = isLeft ? this.he.next : this.ta.prev; cur != this.ta && cur != this.he; cur = isLeft ? cur.next : cur.prev) {
            if (index-- == 0) return cur
        }
        return null
    }
}
```
Python ä»£ç ï¼š
```Python
class Node:
    def __init__(self, _val):
        self.val = _val
        self.prev = None
        self.next = None

class MyLinkedList:
    def __init__(self):
        self.he = Node(-1)
        self.ta = Node(-1)
        self.he.next = self.ta
        self.ta.prev = self.he
        self.sz = 0

    def get(self, index: int) -> int:
        node = self.getNode(index)
        return node.val if node else -1

    def addAtHead(self, val: int) -> None:
        node = Node(val)
        node.next = self.he.next
        node.prev = self.he
        self.he.next.prev = node
        self.he.next = node
        self.sz += 1

    def addAtTail(self, val: int) -> None:
        node = Node(val)
        node.prev = self.ta.prev
        node.next = self.ta
        self.ta.prev.next = node
        self.ta.prev = node
        self.sz += 1

    def addAtIndex(self, index: int, val: int) -> None:
        if index > self.sz:
            return 
        if index <= 0:
            self.addAtHead(val)
        elif index == self.sz:
            self.addAtTail(val)
        else:
            node, cur = Node(val), self.getNode(index)
            node.next = cur
            node.prev = cur.prev
            cur.prev.next = node
            cur.prev = node
            self.sz += 1

    def deleteAtIndex(self, index: int) -> None:
        node = self.getNode(index)
        if node:
            node.prev.next = node.next
            node.next.prev = node.prev
            self.sz -= 1

    def getNode(self, index: int) -> Node | None:
        isLeft = index < self.sz / 2
        if not isLeft:
            index = self.sz - index - 1
        cur = self.he.next if isLeft else self.ta.prev
        while cur != self.he and cur != self.ta:
            if index == 0:
                return cur
            index -= 1
            cur = cur.next if isLeft else cur.prev
        return None
```
* æ—¶é—´å¤æ‚åº¦ï¼šæ¶‰åŠ `index` çš„ç›¸å…³æ“ä½œå¤æ‚åº¦ä¸º $O(index)$ï¼›å…¶ä½™æ“ä½œå‡ä¸º $O(1)$
* ç©ºé—´å¤æ‚åº¦ï¼š$O(n)$

---

### æœ€åŽ

è¿™æ˜¯æˆ‘ä»¬ã€Œåˆ·ç©¿ LeetCodeã€ç³»åˆ—æ–‡ç« çš„ç¬¬ `No.707` ç¯‡ï¼Œç³»åˆ—å¼€å§‹äºŽ 2021/01/01ï¼Œæˆªæ­¢äºŽèµ·å§‹æ—¥ LeetCode ä¸Šå…±æœ‰ 1916 é“é¢˜ç›®ï¼Œéƒ¨åˆ†æ˜¯æœ‰é”é¢˜ï¼Œæˆ‘ä»¬å°†å…ˆæŠŠæ‰€æœ‰ä¸å¸¦é”çš„é¢˜ç›®åˆ·å®Œã€‚

åœ¨è¿™ä¸ªç³»åˆ—æ–‡ç« é‡Œé¢ï¼Œé™¤äº†è®²è§£è§£é¢˜æ€è·¯ä»¥å¤–ï¼Œè¿˜ä¼šå°½å¯èƒ½ç»™å‡ºæœ€ä¸ºç®€æ´çš„ä»£ç ã€‚å¦‚æžœæ¶‰åŠé€šè§£è¿˜ä¼šç›¸åº”çš„ä»£ç æ¨¡æ¿ã€‚

ä¸ºäº†æ–¹ä¾¿å„ä½åŒå­¦èƒ½å¤Ÿç”µè„‘ä¸Šè¿›è¡Œè°ƒè¯•å’Œæäº¤ä»£ç ï¼Œæˆ‘å»ºç«‹äº†ç›¸å…³çš„ä»“åº“ï¼šhttps://github.com/SharingSource/LogicStack-LeetCode ã€‚

åœ¨ä»“åº“åœ°å€é‡Œï¼Œä½ å¯ä»¥çœ‹åˆ°ç³»åˆ—æ–‡ç« çš„é¢˜è§£é“¾æŽ¥ã€ç³»åˆ—æ–‡ç« çš„ç›¸åº”ä»£ç ã€LeetCode åŽŸé¢˜é“¾æŽ¥å’Œå…¶ä»–ä¼˜é€‰é¢˜è§£ã€‚

